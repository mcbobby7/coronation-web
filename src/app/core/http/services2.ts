/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @param token (optional)
     * @return Success
     */
    verifyEmail(token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/VerifyEmail?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }

    /**
     * API to send a verification OTP to user's Mobile Number when user clicks "Verify PhoneNumber"
     * @param mobile (optional)
     * @return Success
     */
    verifyPhoneNumber(mobile: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/VerifyPhoneNumber?";
        if (mobile !== undefined && mobile !== null)
            url_ += "mobile=" + encodeURIComponent("" + mobile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyPhoneNumber(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyPhoneNumber(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Enable user's Mobile No. by providing user's mobile and otp after otp validation was successful.
     * @param mobile (optional)
     * @param otp (optional)
     * @return Success
     */
    enableUserMobile(mobile: string | null | undefined, otp: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/EnableUserMobile?";
        if (mobile !== undefined && mobile !== null)
            url_ += "mobile=" + encodeURIComponent("" + mobile) + "&";
        if (otp !== undefined && otp !== null)
            url_ += "otp=" + encodeURIComponent("" + otp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableUserMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableUserMobile(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEnableUserMobile(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to re-generate and send Email verification token URL to user
     * @param email (optional)
     * @return Success
     */
    generateEmailVerificationToken(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/GenerateEmailVerificationToken?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateEmailVerificationToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateEmailVerificationToken(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateEmailVerificationToken(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    activation(body: ManageKycDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/Activation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processActivation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    changePassword(body: FirstLoginDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param email (optional)
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param userId (optional)
     * @param token (optional)
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class CommunicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API to Fetch Email Settings.
    Note: all filter are optional
     * @return Success
     */
    getAllEmailSettings(): Observable<EmailSettingListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmailSettings(response: HttpResponseBase): Observable<EmailSettingListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingListApiResult>(<any>null);
    }

    /**
     * API to get EmailSetting by id and can be used for update, details etc
     * @param id (optional)
     * @return Success
     */
    getEmailSettingById(id: number | undefined): Observable<EmailSettingApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailSettingById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSettingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettingById(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailSettingById(response: HttpResponseBase): Observable<EmailSettingApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingApiResult>(<any>null);
    }

    /**
     * API for adding/updating EmailSettings
     * @param body (optional)
     * @return Success
     */
    addUpdateEmailSetting(body: EmailSetting | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Communication/AddUpdateEmailSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmailSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmailSetting(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmailSetting(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch TemplateTypes (Promotion, Account Creation etc.) for Dropdowns
    while adding Email Template
     * @return Success
     */
    getAllTemplateTypes(): Observable<IdNameObjListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllTemplateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTemplateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTemplateTypes(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTemplateTypes(response: HttpResponseBase): Observable<IdNameObjListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjListApiResult>(<any>null);
    }

    /**
     * API for adding/updating EmailTemplate
     * @param body (optional)
     * @return Success
     */
    addUpdateEmailTemplate(body: ManageMailTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Communication/AddUpdateEmailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmailTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Email Templates.
    Note: all filter are optional
     * @return Success
     */
    getAllEmailTemplates(): Observable<MailTemplateDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllEmailTemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmailTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmailTemplates(<any>response_);
                } catch (e) {
                    return <Observable<MailTemplateDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailTemplateDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmailTemplates(response: HttpResponseBase): Observable<MailTemplateDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailTemplateDTOListApiResult>(<any>null);
    }

    /**
     * API to get EmailTemplate by id and can be used for update, details etc
     * @param id (optional)
     * @return Success
     */
    getEmailTemplateById(id: number | undefined): Observable<MailTemplateDTOApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailTemplateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateById(<any>response_);
                } catch (e) {
                    return <Observable<MailTemplateDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailTemplateDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailTemplateById(response: HttpResponseBase): Observable<MailTemplateDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailTemplateDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for getting all Companies for dropdowns
     * @return Success
     */
    getcompanies(): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/Company/getcompanies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcompanies(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetcompanies(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }

    /**
     * API for getting all Companies
     * @param companyId (optional)
     * @param regCode (optional)
     * @param coyNo (optional)
     * @return Success
     */
    getallcompanies(companyId: number | undefined, regCode: number | undefined, coyNo: number | undefined): Observable<CompanyIListApiResult> {
        let url_ = this.baseUrl + "/api/Company/getallcompanies?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (regCode === null)
            throw new Error("The parameter 'regCode' cannot be null.");
        else if (regCode !== undefined)
            url_ += "regCode=" + encodeURIComponent("" + regCode) + "&";
        if (coyNo === null)
            throw new Error("The parameter 'coyNo' cannot be null.");
        else if (coyNo !== undefined)
            url_ += "coyNo=" + encodeURIComponent("" + coyNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallcompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallcompanies(<any>response_);
                } catch (e) {
                    return <Observable<CompanyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetallcompanies(response: HttpResponseBase): Observable<CompanyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyIListApiResult>(<any>null);
    }

    /**
     * @param companyId (optional)
     * @param regCode (optional)
     * @param coyNo (optional)
     * @return Success
     */
    getall(companyId: number | undefined, regCode: number | undefined, coyNo: number | undefined): Observable<CompanyIListApiResult> {
        let url_ = this.baseUrl + "/api/Company/getall?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (regCode === null)
            throw new Error("The parameter 'regCode' cannot be null.");
        else if (regCode !== undefined)
            url_ += "regCode=" + encodeURIComponent("" + regCode) + "&";
        if (coyNo === null)
            throw new Error("The parameter 'coyNo' cannot be null.");
        else if (coyNo !== undefined)
            url_ += "coyNo=" + encodeURIComponent("" + coyNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(<any>response_);
                } catch (e) {
                    return <Observable<CompanyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<CompanyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyIListApiResult>(<any>null);
    }

    /**
     * @return Success
     */
    sync(): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Company/sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for getting all Companies where Shareholder have shares for dropdowns
     * @return Success
     */
    getMyRegistrars(): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/GetMyRegistrars";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyRegistrars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyRegistrars(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyRegistrars(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }

    /**
     * API for fetching ShareHolders dashboard Aggregate Values with optional {companyId}
     * @param companyId (optional)
     * @return Success
     */
    fetchShareHolderDashboard(companyId: number | undefined): Observable<VwDashboardApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchShareHolderDashboard?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchShareHolderDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchShareHolderDashboard(<any>response_);
                } catch (e) {
                    return <Observable<VwDashboardApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwDashboardApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchShareHolderDashboard(response: HttpResponseBase): Observable<VwDashboardApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwDashboardApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwDashboardApiResult>(<any>null);
    }

    /**
     * API for fetching ShareHolders Dividends from Top 3 companies
     * @return Success
     */
    fetchShareHolderDividends(): Observable<DashboardData1ListApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchShareHolderDividends";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchShareHolderDividends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchShareHolderDividends(<any>response_);
                } catch (e) {
                    return <Observable<DashboardData1ListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardData1ListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchShareHolderDividends(response: HttpResponseBase): Observable<DashboardData1ListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardData1ListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardData1ListApiResult>(<any>null);
    }

    /**
     * API for fetching ShareHolders ViewHoldings
     * @return Success
     */
    fetchShareHoldingViews(): Observable<DashboardDataListApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchShareHoldingViews";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchShareHoldingViews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchShareHoldingViews(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDataListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDataListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchShareHoldingViews(response: HttpResponseBase): Observable<DashboardDataListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDataListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDataListApiResult>(<any>null);
    }

    /**
     * API for fetching Transaction Histories
     * @param companyId (optional)
     * @param trans_type (optional)
     * @return Success
     */
    fetchTransactionHistories(companyId: number | undefined, trans_type: number | undefined): Observable<DashboardData2ListApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchTransactionHistories?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (trans_type === null)
            throw new Error("The parameter 'trans_type' cannot be null.");
        else if (trans_type !== undefined)
            url_ += "trans_type=" + encodeURIComponent("" + trans_type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTransactionHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTransactionHistories(<any>response_);
                } catch (e) {
                    return <Observable<DashboardData2ListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardData2ListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTransactionHistories(response: HttpResponseBase): Observable<DashboardData2ListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardData2ListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardData2ListApiResult>(<any>null);
    }

    /**
     * API for fetching Dividend Histories
     * @param companyId (optional)
     * @param start_date (optional)
     * @param end_date (optional)
     * @return Success
     */
    fetchDividendHistories(companyId: number | undefined, start_date: Date | null | undefined, end_date: Date | null | undefined): Observable<DashboardData2ListApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchDividendHistories?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toJSON() : "") + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDividendHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDividendHistories(<any>response_);
                } catch (e) {
                    return <Observable<DashboardData2ListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardData2ListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDividendHistories(response: HttpResponseBase): Observable<DashboardData2ListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardData2ListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardData2ListApiResult>(<any>null);
    }

    /**
     * API for fetching Total Valuations
     * @return Success
     */
    fetchTotalValuations(): Observable<DashboardDataListApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchTotalValuations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTotalValuations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTotalValuations(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDataListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDataListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTotalValuations(response: HttpResponseBase): Observable<DashboardDataListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDataListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDataListApiResult>(<any>null);
    }
}

@Injectable()
export class DropdownServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for fetching all Banks for dropdowns
     * @return Success
     */
    banks(): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/Dropdown/Banks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBanks(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processBanks(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }

    /**
     * @param dropdownId (optional)
     * @return Success
     */
    values(dropdownId: number | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Dropdown/Values?";
        if (dropdownId === null)
            throw new Error("The parameter 'dropdownId' cannot be null.");
        else if (dropdownId !== undefined)
            url_ += "dropdownId=" + encodeURIComponent("" + dropdownId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValues(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @return Success
     */
    dropdown(): Observable<DropdownIListApiResult> {
        let url_ = this.baseUrl + "/api/Dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DropdownIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDropdown(response: HttpResponseBase): Observable<DropdownIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownIListApiResult>(<any>null);
    }
}

@Injectable()
export class EventLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @return Success
     */
    fetchEventLogTypes(): Observable<StringIListApiResult> {
        let url_ = this.baseUrl + "/api/EventLog/fetchEventLogTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEventLogTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEventLogTypes(<any>response_);
                } catch (e) {
                    return <Observable<StringIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEventLogTypes(response: HttpResponseBase): Observable<StringIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringIListApiResult>(<any>null);
    }

    /**
     * @param basicInfoId (optional)
     * @return Success
     */
    fetchEventLogs(basicInfoId: number | undefined): Observable<EventLogIListApiResult> {
        let url_ = this.baseUrl + "/api/EventLog/fetchEventLogs?";
        if (basicInfoId === null)
            throw new Error("The parameter 'basicInfoId' cannot be null.");
        else if (basicInfoId !== undefined)
            url_ += "basicInfoId=" + encodeURIComponent("" + basicInfoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEventLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEventLogs(<any>response_);
                } catch (e) {
                    return <Observable<EventLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEventLogs(response: HttpResponseBase): Observable<EventLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventLogIListApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveEventLog(body: EventLog | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/EventLog/saveEventLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEventLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEventLog(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveEventLog(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RedemptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @param basicInfoId (optional)
     * @param id (optional)
     * @param txnref (optional)
     * @return Success
     */
    fetchTransactions(basicInfoId: number | undefined, id: number | undefined, txnref: string | null | undefined): Observable<FundTransactionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Redemption/fetchTransactions?";
        if (basicInfoId === null)
            throw new Error("The parameter 'basicInfoId' cannot be null.");
        else if (basicInfoId !== undefined)
            url_ += "basicInfoId=" + encodeURIComponent("" + basicInfoId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (txnref !== undefined && txnref !== null)
            url_ += "txnref=" + encodeURIComponent("" + txnref) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTransactions(<any>response_);
                } catch (e) {
                    return <Observable<FundTransactionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FundTransactionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTransactions(response: HttpResponseBase): Observable<FundTransactionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundTransactionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FundTransactionDTOIListApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    postTransaction(body: FundTransactionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Redemption/postTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostTransaction(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostTransaction(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GeographyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @return Success
     */
    fetchCountries(): Observable<CountryIListApiResult> {
        let url_ = this.baseUrl + "/api/Geography/FetchCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCountries(response: HttpResponseBase): Observable<CountryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListApiResult>(<any>null);
    }

    /**
     * @param countryId (optional)
     * @param countryCode (optional)
     * @return Success
     */
    countries(countryId: number | undefined, countryCode: string | null | undefined): Observable<CountryIListApiResult> {
        let url_ = this.baseUrl + "/api/Geography/Countries?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<CountryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListApiResult>(<any>null);
    }

    /**
     * @param countryId (optional)
     * @param stateId (optional)
     * @param stateCode (optional)
     * @return Success
     */
    states(countryId: number | undefined, stateId: number | undefined, stateCode: string | null | undefined): Observable<StateIListApiResult> {
        let url_ = this.baseUrl + "/api/Geography/States?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (stateId === null)
            throw new Error("The parameter 'stateId' cannot be null.");
        else if (stateId !== undefined)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        if (stateCode !== undefined && stateCode !== null)
            url_ += "stateCode=" + encodeURIComponent("" + stateCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStates(<any>response_);
                } catch (e) {
                    return <Observable<StateIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processStates(response: HttpResponseBase): Observable<StateIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateIListApiResult>(<any>null);
    }

    /**
     * @param stateId (optional)
     * @param lgaId (optional)
     * @param lgaCode (optional)
     * @return Success
     */
    lgas(stateId: number | undefined, lgaId: number | undefined, lgaCode: string | null | undefined): Observable<LgaIListApiResult> {
        let url_ = this.baseUrl + "/api/Geography/Lgas?";
        if (stateId === null)
            throw new Error("The parameter 'stateId' cannot be null.");
        else if (stateId !== undefined)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        if (lgaId === null)
            throw new Error("The parameter 'lgaId' cannot be null.");
        else if (lgaId !== undefined)
            url_ += "lgaId=" + encodeURIComponent("" + lgaId) + "&";
        if (lgaCode !== undefined && lgaCode !== null)
            url_ += "lgaCode=" + encodeURIComponent("" + lgaCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLgas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLgas(<any>response_);
                } catch (e) {
                    return <Observable<LgaIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LgaIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLgas(response: HttpResponseBase): Observable<LgaIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LgaIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LgaIListApiResult>(<any>null);
    }
}

@Injectable()
export class RedemptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @param basicInfoId (optional)
     * @param id (optional)
     * @param txnref (optional)
     * @return Success
     */
    fetchTransactions(basicInfoId: number | undefined, id: number | undefined, txnref: string | null | undefined): Observable<RedemptionOutputDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Redemptions/fetchTransactions?";
        if (basicInfoId === null)
            throw new Error("The parameter 'basicInfoId' cannot be null.");
        else if (basicInfoId !== undefined)
            url_ += "basicInfoId=" + encodeURIComponent("" + basicInfoId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (txnref !== undefined && txnref !== null)
            url_ += "txnref=" + encodeURIComponent("" + txnref) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTransactions(<any>response_);
                } catch (e) {
                    return <Observable<RedemptionOutputDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RedemptionOutputDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTransactions(response: HttpResponseBase): Observable<RedemptionOutputDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedemptionOutputDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RedemptionOutputDTOIListApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    postTransaction(body: RedemptionInputDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Redemptions/postTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostTransaction(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostTransaction(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    validateTransaction(body: ValidateRRedemptionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Redemptions/validateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateTransaction(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValidateTransaction(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * This endpoint allows you spool the various search types supported in the fetchInvestors endpoint
     * @return Success
     */
    fetchSearchTypes(): Observable<StringListApiResult> {
        let url_ = this.baseUrl + "/api/registration/fetchSearchTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchSearchTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchSearchTypes(<any>response_);
                } catch (e) {
                    return <Observable<StringListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchSearchTypes(response: HttpResponseBase): Observable<StringListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringListApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    fetchInvestors(body: SearchModel[] | null | undefined): Observable<RegistrationSummaryOutputDTOListApiResult> {
        let url_ = this.baseUrl + "/api/registration/fetchInvestors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchInvestors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchInvestors(<any>response_);
                } catch (e) {
                    return <Observable<RegistrationSummaryOutputDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegistrationSummaryOutputDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchInvestors(response: HttpResponseBase): Observable<RegistrationSummaryOutputDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationSummaryOutputDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationSummaryOutputDTOListApiResult>(<any>null);
    }

    /**
     * @param accountCode (optional)
     * @param basicInfoId (optional)
     * @return Success
     */
    fetchInvestorDetails(accountCode: number | undefined, basicInfoId: number | undefined): Observable<RegistrationOutputDTOApiResult> {
        let url_ = this.baseUrl + "/api/registration/fetchInvestorDetails?";
        if (accountCode === null)
            throw new Error("The parameter 'accountCode' cannot be null.");
        else if (accountCode !== undefined)
            url_ += "accountCode=" + encodeURIComponent("" + accountCode) + "&";
        if (basicInfoId === null)
            throw new Error("The parameter 'basicInfoId' cannot be null.");
        else if (basicInfoId !== undefined)
            url_ += "basicInfoId=" + encodeURIComponent("" + basicInfoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchInvestorDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchInvestorDetails(<any>response_);
                } catch (e) {
                    return <Observable<RegistrationOutputDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegistrationOutputDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchInvestorDetails(response: HttpResponseBase): Observable<RegistrationOutputDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationOutputDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationOutputDTOApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveInvestorDetails(body: RegistrationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/registration/saveInvestorDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvestorDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvestorDetails(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveInvestorDetails(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for getting Report listing for ShareHolder Transaction Histories with filter but optional
     * @param companyId (optional)
     * @param trans_type (optional)
     * @param searchText (optional)
     * @param start_date (optional)
     * @param end_date (optional)
     * @param pageSize (optional)
     * @param pageNumber (optional)
     * @return Success
     */
    fetchTransactionHistories(companyId: number | undefined, trans_type: number | undefined, searchText: string | null | undefined, start_date: Date | null | undefined, end_date: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<TransactionHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Report/FetchTransactionHistories?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (trans_type === null)
            throw new Error("The parameter 'trans_type' cannot be null.");
        else if (trans_type !== undefined)
            url_ += "trans_type=" + encodeURIComponent("" + trans_type) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toJSON() : "") + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTransactionHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTransactionHistories(<any>response_);
                } catch (e) {
                    return <Observable<TransactionHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTransactionHistories(response: HttpResponseBase): Observable<TransactionHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionHistoryDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Report listing for ShareHolder Dividend Histories with filter but optional
     * @param companyId (optional)
     * @param searchText (optional)
     * @param start_date (optional)
     * @param end_date (optional)
     * @param pageSize (optional)
     * @param pageNumber (optional)
     * @return Success
     */
    fetchDividendHistories(companyId: number | undefined, searchText: string | null | undefined, start_date: Date | null | undefined, end_date: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<DividendHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Report/FetchDividendHistories?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toJSON() : "") + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDividendHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDividendHistories(<any>response_);
                } catch (e) {
                    return <Observable<DividendHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DividendHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDividendHistories(response: HttpResponseBase): Observable<DividendHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DividendHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DividendHistoryDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Report listing on ShareHolder ViewHoldings with filter but optional
    SearchText cover the followings; (Companies (where Shareholder's have shares))
     * @param companyId (optional)
     * @param trans_type (optional)
     * @param searchText (optional)
     * @param start_date (optional)
     * @param end_date (optional)
     * @param pageSize (optional)
     * @param pageNumber (optional)
     * @return Success
     */
    fetchViewHoldings(companyId: number | undefined, trans_type: number | undefined, searchText: string | null | undefined, start_date: Date | null | undefined, end_date: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<ViewHoldingDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Report/FetchViewHoldings?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (trans_type === null)
            throw new Error("The parameter 'trans_type' cannot be null.");
        else if (trans_type !== undefined)
            url_ += "trans_type=" + encodeURIComponent("" + trans_type) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toJSON() : "") + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchViewHoldings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchViewHoldings(<any>response_);
                } catch (e) {
                    return <Observable<ViewHoldingDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewHoldingDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchViewHoldings(response: HttpResponseBase): Observable<ViewHoldingDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewHoldingDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewHoldingDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    getRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRoles/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for getting all Roles for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @return Success
     */
    getAllRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchAllRoles/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for getting single Role for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @param id (optional)
     * @return Success
     */
    getRole(id: number | undefined): Observable<ApplicationRoleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRole/GetRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<ApplicationRoleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional)
     * @return Success
     */
    createRole(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role/CreateRole/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @return Success
     */
    getRolePermissions(): Observable<RolePermissionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermissions/GetRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<RolePermissionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @param roleId (optional)
     * @return Success
     */
    getRolePermission(roleId: number | undefined): Observable<RolePermissionDTOApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermission/GetRolePermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermission(response: HttpResponseBase): Observable<RolePermissionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class RolePermissionMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    rolePermissionMapping(body: RolePermissionMappingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermissionMapping/RolePermissionMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionMapping(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePermissionMapping(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ServiceRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API to send out an OTP to user's Email/Phone No to validate Request submission.
     * @return Success
     */
    sendRequestToken(): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ServiceRequest/SendRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendRequestToken(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSendRequestToken(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to confirm user's Request OTP with the one sent to both Email/Phone No.
     * @param otp (optional)
     * @return Success
     */
    validateRequestToken(otp: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ServiceRequest/ValidateRequestToken?";
        if (otp !== undefined && otp !== null)
            url_ += "otp=" + encodeURIComponent("" + otp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateRequestToken(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValidateRequestToken(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for making Change of Address Request by Shareholder under a specific Company
     * @param body (optional)
     * @return Success
     */
    changeOfAddress(body: ManageChangeOfAddressDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ServiceRequest/ChangeOfAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeOfAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeOfAddress(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processChangeOfAddress(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for making Account Consolidation Request by Shareholder.
     * @param body (optional)
     * @return Success
     */
    consolidateAccounts(body: ManageAccountConsolidateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ServiceRequest/ConsolidateAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsolidateAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsolidateAccounts(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConsolidateAccounts(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for getting All Change of Address Listing for a particular Shareholder with filter but optional
    SearchText cover the followings; (Company, Country, Old Address, New Address, Emails etc)
     * @param companyId (optional)
     * @param trans_type (optional)
     * @param searchText (optional)
     * @param start_date (optional)
     * @param end_date (optional)
     * @param pageSize (optional)
     * @param pageNumber (optional)
     * @return Success
     */
    fetchAddressChangeRequests(companyId: number | undefined, trans_type: number | undefined, searchText: string | null | undefined, start_date: Date | null | undefined, end_date: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<ChangeOfAddressDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ServiceRequest/FetchAddressChangeRequests?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (trans_type === null)
            throw new Error("The parameter 'trans_type' cannot be null.");
        else if (trans_type !== undefined)
            url_ += "trans_type=" + encodeURIComponent("" + trans_type) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toJSON() : "") + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent(end_date ? "" + end_date.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAddressChangeRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAddressChangeRequests(<any>response_);
                } catch (e) {
                    return <Observable<ChangeOfAddressDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangeOfAddressDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAddressChangeRequests(response: HttpResponseBase): Observable<ChangeOfAddressDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeOfAddressDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangeOfAddressDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * API for add/updating features for subscription
     * @param body (optional)
     * @return Success
     */
    addUpdateFeature(body: FeatureDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/AddUpdateFeature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateFeature(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateFeature(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for getting All Features Listing with filter but optional
    SearchText cover the Name
     * @param searchText (optional)
     * @param pageSize (optional)
     * @param pageNumber (optional)
     * @return Success
     */
    fetchAllFeatures(searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<FeatureDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/FetchAllFeatures?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllFeatures(<any>response_);
                } catch (e) {
                    return <Observable<FeatureDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FeatureDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllFeatures(response: HttpResponseBase): Observable<FeatureDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeatureDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting All Features for dropdowns
     * @return Success
     */
    fetchFeatures(): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/FetchFeatures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchFeatures(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchFeatures(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }

    /**
     * API to delete feature
     * @param id (optional)
     * @return Success
     */
    deleteFeature(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Subscription/DeleteFeature?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFeature(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFeature(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * API for add/updating Subscription
     * @param body (optional)
     * @return Success
     */
    addUpdateSubscription(body: ManageSubscriptionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/AddUpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateSubscription(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for getting All Subscription Listing with filter but optional
    SearchText cover the Name
     * @param searchText (optional)
     * @param pageSize (optional)
     * @param pageNumber (optional)
     * @return Success
     */
    fetchAllSubscriptions(searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<SubscriptionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/FetchAllSubscriptions?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllSubscriptions(response: HttpResponseBase): Observable<SubscriptionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Single Subscription and all attached features for details by id for CRUD Operation
     * @param id (optional)
     * @return Success
     */
    fetchSubscription(id: number | undefined): Observable<SubscriptionDTOApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/FetchSubscription?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchSubscription(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchSubscription(response: HttpResponseBase): Observable<SubscriptionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionDTOApiResult>(<any>null);
    }

    /**
     * API to delete Subscription
     * @param id (optional)
     * @return Success
     */
    deleteSubscription(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Subscription/DeleteSubscription?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * API to verify Share Holder Subscription plan payment while upgrading up their account
     * @param subscriptionId (optional)
     * @param reference (optional)
     * @return Success
     */
    subscriptionPayment(subscriptionId: number | undefined, reference: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/SubscriptionPayment?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (reference !== undefined && reference !== null)
            url_ += "reference=" + encodeURIComponent("" + reference) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubscriptionPayment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchUserSubscription(): Observable<UserSubscriptionDTOApiResult> {
        let url_ = this.baseUrl + "/api/Subscription/FetchUserSubscription";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchUserSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchUserSubscription(<any>response_);
                } catch (e) {
                    return <Observable<UserSubscriptionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSubscriptionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchUserSubscription(response: HttpResponseBase): Observable<UserSubscriptionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSubscriptionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSubscriptionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class UserManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://coronation-apis.smartace.ng";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    registerUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchAllUsers(): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/FetchAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllUsers(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

export class BankInfoDTO implements IBankInfoDTO {
    id!: number;
    accountNo!: string | undefined;
    accountName!: string | undefined;
    bankName!: string | undefined;
    bankCode!: string | undefined;
    bankId!: number | undefined;

    constructor(data?: IBankInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountNo = _data["accountNo"];
            this.accountName = _data["accountName"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.bankId = _data["bankId"];
        }
    }

    static fromJS(data: any): BankInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BankInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNo"] = this.accountNo;
        data["accountName"] = this.accountName;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["bankId"] = this.bankId;
        return data;
    }

    clone(): BankInfoDTO {
        const json = this.toJSON();
        let result = new BankInfoDTO();
        result.init(json);
        return result;
    }
}

export interface IBankInfoDTO {
    id: number;
    accountNo: string | undefined;
    accountName: string | undefined;
    bankName: string | undefined;
    bankCode: string | undefined;
    bankId: number | undefined;
}

export class IdentityInfoDTO implements IIdentityInfoDTO {
    id!: number;
    signature!: string | undefined;
    validId!: string | undefined;
    validId_ExpDate!: Date | undefined;
    validId_Number!: string | undefined;
    validId_Name!: string | undefined;

    constructor(data?: IIdentityInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.signature = _data["signature"];
            this.validId = _data["validId"];
            this.validId_ExpDate = _data["validId_ExpDate"] ? new Date(_data["validId_ExpDate"].toString()) : <any>undefined;
            this.validId_Number = _data["validId_Number"];
            this.validId_Name = _data["validId_Name"];
        }
    }

    static fromJS(data: any): IdentityInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["signature"] = this.signature;
        data["validId"] = this.validId;
        data["validId_ExpDate"] = this.validId_ExpDate ? this.validId_ExpDate.toISOString() : <any>undefined;
        data["validId_Number"] = this.validId_Number;
        data["validId_Name"] = this.validId_Name;
        return data;
    }

    clone(): IdentityInfoDTO {
        const json = this.toJSON();
        let result = new IdentityInfoDTO();
        result.init(json);
        return result;
    }
}

export interface IIdentityInfoDTO {
    id: number;
    signature: string | undefined;
    validId: string | undefined;
    validId_ExpDate: Date | undefined;
    validId_Number: string | undefined;
    validId_Name: string | undefined;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    first_name!: string | undefined;
    last_name!: string | undefined;
    other_name!: string | undefined;
    readonly full_name!: string | undefined;
    email!: string | undefined;
    holder_type!: string | undefined;
    phone_number!: string | undefined;
    bvn!: string | undefined;
    nin!: string | undefined;
    tin!: string | undefined;
    rc_number!: string | undefined;
    mobile_verify_otp!: string | undefined;
    otp!: string | undefined;
    email_confirmed!: boolean;
    mobile_enabled!: boolean;
    is_activated!: boolean;
    account_details!: BankInfoDTO[] | undefined;
    identity_info!: IdentityInfoDTO[] | undefined;
    signature!: string | undefined;
    valid_ID!: string | undefined;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    subscriptionId!: number | undefined;
    subMode!: number;
    isFreeMode!: boolean;
    lstPermissions!: string[] | undefined;
    retId!: number;
    txnReference!: string | undefined;
    message!: string | undefined;
    isFirstTimeLogin!: boolean;
    isSuccessful!: boolean;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.other_name = _data["other_name"];
            (<any>this).full_name = _data["full_name"];
            this.email = _data["email"];
            this.holder_type = _data["holder_type"];
            this.phone_number = _data["phone_number"];
            this.bvn = _data["bvn"];
            this.nin = _data["nin"];
            this.tin = _data["tin"];
            this.rc_number = _data["rc_number"];
            this.mobile_verify_otp = _data["mobile_verify_otp"];
            this.otp = _data["otp"];
            this.email_confirmed = _data["email_confirmed"];
            this.mobile_enabled = _data["mobile_enabled"];
            this.is_activated = _data["is_activated"];
            if (Array.isArray(_data["account_details"])) {
                this.account_details = [] as any;
                for (let item of _data["account_details"])
                    this.account_details!.push(BankInfoDTO.fromJS(item));
            }
            if (Array.isArray(_data["identity_info"])) {
                this.identity_info = [] as any;
                for (let item of _data["identity_info"])
                    this.identity_info!.push(IdentityInfoDTO.fromJS(item));
            }
            this.signature = _data["signature"];
            this.valid_ID = _data["valid_ID"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.subscriptionId = _data["subscriptionId"];
            this.subMode = _data["subMode"];
            this.isFreeMode = _data["isFreeMode"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.retId = _data["retId"];
            this.txnReference = _data["txnReference"];
            this.message = _data["message"];
            this.isFirstTimeLogin = _data["isFirstTimeLogin"];
            this.isSuccessful = _data["isSuccessful"];
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["other_name"] = this.other_name;
        data["full_name"] = this.full_name;
        data["email"] = this.email;
        data["holder_type"] = this.holder_type;
        data["phone_number"] = this.phone_number;
        data["bvn"] = this.bvn;
        data["nin"] = this.nin;
        data["tin"] = this.tin;
        data["rc_number"] = this.rc_number;
        data["mobile_verify_otp"] = this.mobile_verify_otp;
        data["otp"] = this.otp;
        data["email_confirmed"] = this.email_confirmed;
        data["mobile_enabled"] = this.mobile_enabled;
        data["is_activated"] = this.is_activated;
        if (Array.isArray(this.account_details)) {
            data["account_details"] = [];
            for (let item of this.account_details)
                data["account_details"].push(item.toJSON());
        }
        if (Array.isArray(this.identity_info)) {
            data["identity_info"] = [];
            for (let item of this.identity_info)
                data["identity_info"].push(item.toJSON());
        }
        data["signature"] = this.signature;
        data["valid_ID"] = this.valid_ID;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["subscriptionId"] = this.subscriptionId;
        data["subMode"] = this.subMode;
        data["isFreeMode"] = this.isFreeMode;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["retId"] = this.retId;
        data["txnReference"] = this.txnReference;
        data["message"] = this.message;
        data["isFirstTimeLogin"] = this.isFirstTimeLogin;
        data["isSuccessful"] = this.isSuccessful;
        return data;
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    first_name: string | undefined;
    last_name: string | undefined;
    other_name: string | undefined;
    full_name: string | undefined;
    email: string | undefined;
    holder_type: string | undefined;
    phone_number: string | undefined;
    bvn: string | undefined;
    nin: string | undefined;
    tin: string | undefined;
    rc_number: string | undefined;
    mobile_verify_otp: string | undefined;
    otp: string | undefined;
    email_confirmed: boolean;
    mobile_enabled: boolean;
    is_activated: boolean;
    account_details: BankInfoDTO[] | undefined;
    identity_info: IdentityInfoDTO[] | undefined;
    signature: string | undefined;
    valid_ID: string | undefined;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    subscriptionId: number | undefined;
    subMode: number;
    isFreeMode: boolean;
    lstPermissions: string[] | undefined;
    retId: number;
    txnReference: string | undefined;
    message: string | undefined;
    isFirstTimeLogin: boolean;
    isSuccessful: boolean;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
}

export class MessageOut implements IMessageOut {
    retId!: number;
    txnReference!: string | undefined;
    message!: string | undefined;
    isFirstTimeLogin!: boolean;
    isSuccessful!: boolean;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retId = _data["retId"];
            this.txnReference = _data["txnReference"];
            this.message = _data["message"];
            this.isFirstTimeLogin = _data["isFirstTimeLogin"];
            this.isSuccessful = _data["isSuccessful"];
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retId"] = this.retId;
        data["txnReference"] = this.txnReference;
        data["message"] = this.message;
        data["isFirstTimeLogin"] = this.isFirstTimeLogin;
        data["isSuccessful"] = this.isSuccessful;
        return data;
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    retId: number;
    txnReference: string | undefined;
    message: string | undefined;
    isFirstTimeLogin: boolean;
    isSuccessful: boolean;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
}

export class ManageKycDTO implements IManageKycDTO {
    id!: number;
    isOnboarding!: boolean;
    lastName!: string;
    firstName!: string;
    otherName!: string | undefined;
    email!: string;
    holder_type!: string;
    mobileNo!: string;
    alternateMobileNo!: string | undefined;
    bankInfos!: string | undefined;
    identityInfos!: string | undefined;
    bvn!: string | undefined;
    nin!: string | undefined;
    tin!: string | undefined;
    rC_NO!: string | undefined;

    constructor(data?: IManageKycDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isOnboarding = _data["isOnboarding"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.otherName = _data["otherName"];
            this.email = _data["email"];
            this.holder_type = _data["holder_type"];
            this.mobileNo = _data["mobileNo"];
            this.alternateMobileNo = _data["alternateMobileNo"];
            this.bankInfos = _data["bankInfos"];
            this.identityInfos = _data["identityInfos"];
            this.bvn = _data["bvn"];
            this.nin = _data["nin"];
            this.tin = _data["tin"];
            this.rC_NO = _data["rC_NO"];
        }
    }

    static fromJS(data: any): ManageKycDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageKycDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isOnboarding"] = this.isOnboarding;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["otherName"] = this.otherName;
        data["email"] = this.email;
        data["holder_type"] = this.holder_type;
        data["mobileNo"] = this.mobileNo;
        data["alternateMobileNo"] = this.alternateMobileNo;
        data["bankInfos"] = this.bankInfos;
        data["identityInfos"] = this.identityInfos;
        data["bvn"] = this.bvn;
        data["nin"] = this.nin;
        data["tin"] = this.tin;
        data["rC_NO"] = this.rC_NO;
        return data;
    }

    clone(): ManageKycDTO {
        const json = this.toJSON();
        let result = new ManageKycDTO();
        result.init(json);
        return result;
    }
}

export interface IManageKycDTO {
    id: number;
    isOnboarding: boolean;
    lastName: string;
    firstName: string;
    otherName: string | undefined;
    email: string;
    holder_type: string;
    mobileNo: string;
    alternateMobileNo: string | undefined;
    bankInfos: string | undefined;
    identityInfos: string | undefined;
    bvn: string | undefined;
    nin: string | undefined;
    tin: string | undefined;
    rC_NO: string | undefined;
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
}

export class FirstLoginDTO implements IFirstLoginDTO {
    currentPassword!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IFirstLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): FirstLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FirstLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): FirstLoginDTO {
        const json = this.toJSON();
        let result = new FirstLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IFirstLoginDTO {
    currentPassword: string;
    password: string;
    confirmPassword: string;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string | undefined;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string | undefined;
    password: string;
    confirmPassword: string | undefined;
}

export class EmailSetting implements IEmailSetting {
    emailUserName!: string | undefined;
    emailHost!: string | undefined;
    emailPort!: number;
    emailPassword!: string | undefined;
    enableSSLForEmail!: boolean;
    emailFromAddress!: string | undefined;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IEmailSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailUserName = _data["emailUserName"];
            this.emailHost = _data["emailHost"];
            this.emailPort = _data["emailPort"];
            this.emailPassword = _data["emailPassword"];
            this.enableSSLForEmail = _data["enableSSLForEmail"];
            this.emailFromAddress = _data["emailFromAddress"];
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): EmailSetting {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailUserName"] = this.emailUserName;
        data["emailHost"] = this.emailHost;
        data["emailPort"] = this.emailPort;
        data["emailPassword"] = this.emailPassword;
        data["enableSSLForEmail"] = this.enableSSLForEmail;
        data["emailFromAddress"] = this.emailFromAddress;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): EmailSetting {
        const json = this.toJSON();
        let result = new EmailSetting();
        result.init(json);
        return result;
    }
}

export interface IEmailSetting {
    emailUserName: string | undefined;
    emailHost: string | undefined;
    emailPort: number;
    emailPassword: string | undefined;
    enableSSLForEmail: boolean;
    emailFromAddress: string | undefined;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class EmailSettingListApiResult implements IEmailSettingListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailSetting[] | undefined;
    totalCount!: number;

    constructor(data?: IEmailSettingListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailSetting.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailSettingListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EmailSettingListApiResult {
        const json = this.toJSON();
        let result = new EmailSettingListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailSetting[] | undefined;
    totalCount: number;
}

export class EmailSettingApiResult implements IEmailSettingApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailSetting;
    totalCount!: number;

    constructor(data?: IEmailSettingApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailSetting.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailSettingApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EmailSettingApiResult {
        const json = this.toJSON();
        let result = new EmailSettingApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailSetting;
    totalCount: number;
}

export class IdNameObj implements IIdNameObj {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIdNameObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameObj {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): IdNameObj {
        const json = this.toJSON();
        let result = new IdNameObj();
        result.init(json);
        return result;
    }
}

export interface IIdNameObj {
    id: number;
    name: string | undefined;
}

export class IdNameObjListApiResult implements IIdNameObjListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IdNameObj[] | undefined;
    totalCount!: number;

    constructor(data?: IIdNameObjListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdNameObj.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdNameObjListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObjListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): IdNameObjListApiResult {
        const json = this.toJSON();
        let result = new IdNameObjListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIdNameObjListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IdNameObj[] | undefined;
    totalCount: number;
}

export class ManageMailTemplateDTO implements IManageMailTemplateDTO {
    id!: number;
    emailTemplateTypeId!: number;
    name!: string | undefined;
    subject!: string;
    body!: string;

    constructor(data?: IManageMailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): ManageMailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageMailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }

    clone(): ManageMailTemplateDTO {
        const json = this.toJSON();
        let result = new ManageMailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IManageMailTemplateDTO {
    id: number;
    emailTemplateTypeId: number;
    name: string | undefined;
    subject: string;
    body: string;
}

export class MailTemplateDTO implements IMailTemplateDTO {
    id!: number;
    name!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    emailTemplateTypeId!: number;
    templateType!: string | undefined;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IMailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.templateType = _data["templateType"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): MailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["templateType"] = this.templateType;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data;
    }

    clone(): MailTemplateDTO {
        const json = this.toJSON();
        let result = new MailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTO {
    id: number;
    name: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    emailTemplateTypeId: number;
    templateType: string | undefined;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class MailTemplateDTOListApiResult implements IMailTemplateDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MailTemplateDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IMailTemplateDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MailTemplateDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MailTemplateDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MailTemplateDTOListApiResult {
        const json = this.toJSON();
        let result = new MailTemplateDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MailTemplateDTO[] | undefined;
    totalCount: number;
}

export class MailTemplateDTOApiResult implements IMailTemplateDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MailTemplateDTO;
    totalCount!: number;

    constructor(data?: IMailTemplateDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MailTemplateDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MailTemplateDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MailTemplateDTOApiResult {
        const json = this.toJSON();
        let result = new MailTemplateDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MailTemplateDTO;
    totalCount: number;
}

export class IdNameObjIListApiResult implements IIdNameObjIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IdNameObj[] | undefined;
    totalCount!: number;

    constructor(data?: IIdNameObjIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdNameObj.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdNameObjIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObjIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): IdNameObjIListApiResult {
        const json = this.toJSON();
        let result = new IdNameObjIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIdNameObjIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IdNameObj[] | undefined;
    totalCount: number;
}

export class Company implements ICompany {
    regCode!: number;
    coyNo!: number;
    coyName!: string | undefined;
    secType!: string | undefined;
    coyAddress!: string | undefined;
    description!: string | undefined;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regCode = _data["regCode"];
            this.coyNo = _data["coyNo"];
            this.coyName = _data["coyName"];
            this.secType = _data["secType"];
            this.coyAddress = _data["coyAddress"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regCode"] = this.regCode;
        data["coyNo"] = this.coyNo;
        data["coyName"] = this.coyName;
        data["secType"] = this.secType;
        data["coyAddress"] = this.coyAddress;
        data["description"] = this.description;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    regCode: number;
    coyNo: number;
    coyName: string | undefined;
    secType: string | undefined;
    coyAddress: string | undefined;
    description: string | undefined;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class CompanyIListApiResult implements ICompanyIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Company[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Company.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CompanyIListApiResult {
        const json = this.toJSON();
        let result = new CompanyIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Company[] | undefined;
    totalCount: number;
}

export class VwDashboard implements IVwDashboard {
    totalDividend!: number;
    totalValuation!: number;
    totalShares!: number;
    currentValues!: number;
    claimedDividend!: number;
    unClaimedDividend!: number;

    constructor(data?: IVwDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalDividend = _data["totalDividend"];
            this.totalValuation = _data["totalValuation"];
            this.totalShares = _data["totalShares"];
            this.currentValues = _data["currentValues"];
            this.claimedDividend = _data["claimedDividend"];
            this.unClaimedDividend = _data["unClaimedDividend"];
        }
    }

    static fromJS(data: any): VwDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new VwDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalDividend"] = this.totalDividend;
        data["totalValuation"] = this.totalValuation;
        data["totalShares"] = this.totalShares;
        data["currentValues"] = this.currentValues;
        data["claimedDividend"] = this.claimedDividend;
        data["unClaimedDividend"] = this.unClaimedDividend;
        return data;
    }

    clone(): VwDashboard {
        const json = this.toJSON();
        let result = new VwDashboard();
        result.init(json);
        return result;
    }
}

export interface IVwDashboard {
    totalDividend: number;
    totalValuation: number;
    totalShares: number;
    currentValues: number;
    claimedDividend: number;
    unClaimedDividend: number;
}

export class VwDashboardApiResult implements IVwDashboardApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwDashboard;
    totalCount!: number;

    constructor(data?: IVwDashboardApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwDashboard.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwDashboardApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwDashboardApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): VwDashboardApiResult {
        const json = this.toJSON();
        let result = new VwDashboardApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwDashboardApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwDashboard;
    totalCount: number;
}

export class DashboardData1 implements IDashboardData1 {
    name!: string | undefined;
    value!: number;

    constructor(data?: IDashboardData1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DashboardData1 {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): DashboardData1 {
        const json = this.toJSON();
        let result = new DashboardData1();
        result.init(json);
        return result;
    }
}

export interface IDashboardData1 {
    name: string | undefined;
    value: number;
}

export class DashboardData1ListApiResult implements IDashboardData1ListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DashboardData1[] | undefined;
    totalCount!: number;

    constructor(data?: IDashboardData1ListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DashboardData1.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DashboardData1ListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData1ListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DashboardData1ListApiResult {
        const json = this.toJSON();
        let result = new DashboardData1ListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDashboardData1ListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DashboardData1[] | undefined;
    totalCount: number;
}

export class DashboardData implements IDashboardData {
    category!: string | undefined;
    name!: string | undefined;
    value!: number;

    constructor(data?: IDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): DashboardData {
        const json = this.toJSON();
        let result = new DashboardData();
        result.init(json);
        return result;
    }
}

export interface IDashboardData {
    category: string | undefined;
    name: string | undefined;
    value: number;
}

export class DashboardDataListApiResult implements IDashboardDataListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DashboardData[] | undefined;
    totalCount!: number;

    constructor(data?: IDashboardDataListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DashboardData.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DashboardDataListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDataListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DashboardDataListApiResult {
        const json = this.toJSON();
        let result = new DashboardDataListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDashboardDataListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DashboardData[] | undefined;
    totalCount: number;
}

export class DashboardData2 implements IDashboardData2 {
    paymentNo!: number;
    dividend!: number;
    dividendStatus!: string | undefined;
    unitOfShares!: number;
    description!: string | undefined;
    dateCreated!: Date | undefined;
    pricePerUnit!: number;

    constructor(data?: IDashboardData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentNo = _data["paymentNo"];
            this.dividend = _data["dividend"];
            this.dividendStatus = _data["dividendStatus"];
            this.unitOfShares = _data["unitOfShares"];
            this.description = _data["description"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.pricePerUnit = _data["pricePerUnit"];
        }
    }

    static fromJS(data: any): DashboardData2 {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentNo"] = this.paymentNo;
        data["dividend"] = this.dividend;
        data["dividendStatus"] = this.dividendStatus;
        data["unitOfShares"] = this.unitOfShares;
        data["description"] = this.description;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["pricePerUnit"] = this.pricePerUnit;
        return data;
    }

    clone(): DashboardData2 {
        const json = this.toJSON();
        let result = new DashboardData2();
        result.init(json);
        return result;
    }
}

export interface IDashboardData2 {
    paymentNo: number;
    dividend: number;
    dividendStatus: string | undefined;
    unitOfShares: number;
    description: string | undefined;
    dateCreated: Date | undefined;
    pricePerUnit: number;
}

export class DashboardData2ListApiResult implements IDashboardData2ListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DashboardData2[] | undefined;
    totalCount!: number;

    constructor(data?: IDashboardData2ListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DashboardData2.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DashboardData2ListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData2ListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DashboardData2ListApiResult {
        const json = this.toJSON();
        let result = new DashboardData2ListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDashboardData2ListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DashboardData2[] | undefined;
    totalCount: number;
}

export class Dropdown implements IDropdown {
    name!: string | undefined;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IDropdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): Dropdown {
        data = typeof data === 'object' ? data : {};
        let result = new Dropdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): Dropdown {
        const json = this.toJSON();
        let result = new Dropdown();
        result.init(json);
        return result;
    }
}

export interface IDropdown {
    name: string | undefined;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class DropdownIListApiResult implements IDropdownIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Dropdown[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Dropdown.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DropdownIListApiResult {
        const json = this.toJSON();
        let result = new DropdownIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Dropdown[] | undefined;
    totalCount: number;
}

export class DropdownValue implements IDropdownValue {
    dropdownId!: number;
    title!: string | undefined;
    code!: string | undefined;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IDropdownValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dropdownId = _data["dropdownId"];
            this.title = _data["title"];
            this.code = _data["code"];
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): DropdownValue {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dropdownId"] = this.dropdownId;
        data["title"] = this.title;
        data["code"] = this.code;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): DropdownValue {
        const json = this.toJSON();
        let result = new DropdownValue();
        result.init(json);
        return result;
    }
}

export interface IDropdownValue {
    dropdownId: number;
    title: string | undefined;
    code: string | undefined;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class DropdownValueIListApiResult implements IDropdownValueIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValue[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValue.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DropdownValueIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValue[] | undefined;
    totalCount: number;
}

export class StringIListApiResult implements IStringIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: string[] | undefined;
    totalCount!: number;

    constructor(data?: IStringIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StringIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StringIListApiResult {
        const json = this.toJSON();
        let result = new StringIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IStringIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: string[] | undefined;
    totalCount: number;
}

export class BankInfo implements IBankInfo {
    basicInfoId!: number;
    bvn!: string | undefined;
    accountNo!: string | undefined;
    accountName!: string | undefined;
    bankId!: number | undefined;
    isDefault!: boolean | undefined;
    basicInfo!: BasicInfo;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IBankInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.bvn = _data["bvn"];
            this.accountNo = _data["accountNo"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.isDefault = _data["isDefault"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): BankInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["bvn"] = this.bvn;
        data["accountNo"] = this.accountNo;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["isDefault"] = this.isDefault;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): BankInfo {
        const json = this.toJSON();
        let result = new BankInfo();
        result.init(json);
        return result;
    }
}

export interface IBankInfo {
    basicInfoId: number;
    bvn: string | undefined;
    accountNo: string | undefined;
    accountName: string | undefined;
    bankId: number | undefined;
    isDefault: boolean | undefined;
    basicInfo: BasicInfo;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class ContactInfo implements IContactInfo {
    basicInfoId!: number;
    address!: string | undefined;
    city!: string | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    mobilePhone!: string | undefined;
    homePhone!: string | undefined;
    emailAddress!: string | undefined;
    webAddress!: string | undefined;
    isDefault!: boolean;
    basicInfo!: BasicInfo;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.mobilePhone = _data["mobilePhone"];
            this.homePhone = _data["homePhone"];
            this.emailAddress = _data["emailAddress"];
            this.webAddress = _data["webAddress"];
            this.isDefault = _data["isDefault"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): ContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["address"] = this.address;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["mobilePhone"] = this.mobilePhone;
        data["homePhone"] = this.homePhone;
        data["emailAddress"] = this.emailAddress;
        data["webAddress"] = this.webAddress;
        data["isDefault"] = this.isDefault;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): ContactInfo {
        const json = this.toJSON();
        let result = new ContactInfo();
        result.init(json);
        return result;
    }
}

export interface IContactInfo {
    basicInfoId: number;
    address: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    mobilePhone: string | undefined;
    homePhone: string | undefined;
    emailAddress: string | undefined;
    webAddress: string | undefined;
    isDefault: boolean;
    basicInfo: BasicInfo;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class EmploymentInfo implements IEmploymentInfo {
    basicInfoId!: number;
    employeeId!: string | undefined;
    jobTitle!: string | undefined;
    employerName!: string | undefined;
    employerAddress!: string | undefined;
    employerPhone!: string | undefined;
    employerEmail!: string | undefined;
    employerUrl!: string | undefined;
    isCurrent!: boolean | undefined;
    basicInfo!: BasicInfo;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IEmploymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.employeeId = _data["employeeId"];
            this.jobTitle = _data["jobTitle"];
            this.employerName = _data["employerName"];
            this.employerAddress = _data["employerAddress"];
            this.employerPhone = _data["employerPhone"];
            this.employerEmail = _data["employerEmail"];
            this.employerUrl = _data["employerUrl"];
            this.isCurrent = _data["isCurrent"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): EmploymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["employeeId"] = this.employeeId;
        data["jobTitle"] = this.jobTitle;
        data["employerName"] = this.employerName;
        data["employerAddress"] = this.employerAddress;
        data["employerPhone"] = this.employerPhone;
        data["employerEmail"] = this.employerEmail;
        data["employerUrl"] = this.employerUrl;
        data["isCurrent"] = this.isCurrent;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): EmploymentInfo {
        const json = this.toJSON();
        let result = new EmploymentInfo();
        result.init(json);
        return result;
    }
}

export interface IEmploymentInfo {
    basicInfoId: number;
    employeeId: string | undefined;
    jobTitle: string | undefined;
    employerName: string | undefined;
    employerAddress: string | undefined;
    employerPhone: string | undefined;
    employerEmail: string | undefined;
    employerUrl: string | undefined;
    isCurrent: boolean | undefined;
    basicInfo: BasicInfo;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class Identification implements IIdentification {
    basicInfoId!: number;
    idNo!: string | undefined;
    issueDate!: Date | undefined;
    expiryDate!: Date | undefined;
    issueAuthority!: string | undefined;
    comment!: string | undefined;
    isDefault!: boolean;
    basicInfo!: BasicInfo;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IIdentification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.idNo = _data["idNo"];
            this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? new Date(_data["expiryDate"].toString()) : <any>undefined;
            this.issueAuthority = _data["issueAuthority"];
            this.comment = _data["comment"];
            this.isDefault = _data["isDefault"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): Identification {
        data = typeof data === 'object' ? data : {};
        let result = new Identification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["idNo"] = this.idNo;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["issueAuthority"] = this.issueAuthority;
        data["comment"] = this.comment;
        data["isDefault"] = this.isDefault;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): Identification {
        const json = this.toJSON();
        let result = new Identification();
        result.init(json);
        return result;
    }
}

export interface IIdentification {
    basicInfoId: number;
    idNo: string | undefined;
    issueDate: Date | undefined;
    expiryDate: Date | undefined;
    issueAuthority: string | undefined;
    comment: string | undefined;
    isDefault: boolean;
    basicInfo: BasicInfo;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class NextOfKin implements INextOfKin {
    basicInfoId!: number;
    title!: string | undefined;
    lastName!: string | undefined;
    firstName!: string | undefined;
    otherName!: string | undefined;
    address!: string | undefined;
    city!: string | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    phone!: string | undefined;
    email!: string | undefined;
    relationship!: string | undefined;
    basicInfo!: BasicInfo;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: INextOfKin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.title = _data["title"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.otherName = _data["otherName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.relationship = _data["relationship"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): NextOfKin {
        data = typeof data === 'object' ? data : {};
        let result = new NextOfKin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["title"] = this.title;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["otherName"] = this.otherName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["relationship"] = this.relationship;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): NextOfKin {
        const json = this.toJSON();
        let result = new NextOfKin();
        result.init(json);
        return result;
    }
}

export interface INextOfKin {
    basicInfoId: number;
    title: string | undefined;
    lastName: string | undefined;
    firstName: string | undefined;
    otherName: string | undefined;
    address: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    phone: string | undefined;
    email: string | undefined;
    relationship: string | undefined;
    basicInfo: BasicInfo;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class SignatureInfo implements ISignatureInfo {
    basicInfoId!: number;
    signatureBase64Str!: string | undefined;
    comment!: string | undefined;
    basicInfo!: BasicInfo;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: ISignatureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.signatureBase64Str = _data["signatureBase64Str"];
            this.comment = _data["comment"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): SignatureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SignatureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["signatureBase64Str"] = this.signatureBase64Str;
        data["comment"] = this.comment;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): SignatureInfo {
        const json = this.toJSON();
        let result = new SignatureInfo();
        result.init(json);
        return result;
    }
}

export interface ISignatureInfo {
    basicInfoId: number;
    signatureBase64Str: string | undefined;
    comment: string | undefined;
    basicInfo: BasicInfo;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class BasicInfo implements IBasicInfo {
    accountCode!: number;
    title!: string | undefined;
    refId!: number;
    customerId!: number;
    lastName!: string | undefined;
    firstName!: string | undefined;
    otherName!: string | undefined;
    gender!: string | undefined;
    dateOfBirth!: Date | undefined;
    countryOfOriginId!: number | undefined;
    stateOfOriginId!: number | undefined;
    lgaOfOriginId!: number | undefined;
    relationshipManager!: string | undefined;
    introducerType!: string | undefined;
    introducer!: string | undefined;
    transactionReference!: string | undefined;
    maidenName!: string | undefined;
    chn!: string | undefined;
    shareHoderTypeCode!: string | undefined;
    companyRegCode!: number;
    bankInfos!: BankInfo[] | undefined;
    contactInfos!: ContactInfo[] | undefined;
    employmentInfos!: EmploymentInfo[] | undefined;
    identifications!: Identification[] | undefined;
    nextOfKins!: NextOfKin[] | undefined;
    signatureInfos!: SignatureInfo[] | undefined;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IBasicInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountCode = _data["accountCode"];
            this.title = _data["title"];
            this.refId = _data["refId"];
            this.customerId = _data["customerId"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.otherName = _data["otherName"];
            this.gender = _data["gender"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.countryOfOriginId = _data["countryOfOriginId"];
            this.stateOfOriginId = _data["stateOfOriginId"];
            this.lgaOfOriginId = _data["lgaOfOriginId"];
            this.relationshipManager = _data["relationshipManager"];
            this.introducerType = _data["introducerType"];
            this.introducer = _data["introducer"];
            this.transactionReference = _data["transactionReference"];
            this.maidenName = _data["maidenName"];
            this.chn = _data["chn"];
            this.shareHoderTypeCode = _data["shareHoderTypeCode"];
            this.companyRegCode = _data["companyRegCode"];
            if (Array.isArray(_data["bankInfos"])) {
                this.bankInfos = [] as any;
                for (let item of _data["bankInfos"])
                    this.bankInfos!.push(BankInfo.fromJS(item));
            }
            if (Array.isArray(_data["contactInfos"])) {
                this.contactInfos = [] as any;
                for (let item of _data["contactInfos"])
                    this.contactInfos!.push(ContactInfo.fromJS(item));
            }
            if (Array.isArray(_data["employmentInfos"])) {
                this.employmentInfos = [] as any;
                for (let item of _data["employmentInfos"])
                    this.employmentInfos!.push(EmploymentInfo.fromJS(item));
            }
            if (Array.isArray(_data["identifications"])) {
                this.identifications = [] as any;
                for (let item of _data["identifications"])
                    this.identifications!.push(Identification.fromJS(item));
            }
            if (Array.isArray(_data["nextOfKins"])) {
                this.nextOfKins = [] as any;
                for (let item of _data["nextOfKins"])
                    this.nextOfKins!.push(NextOfKin.fromJS(item));
            }
            if (Array.isArray(_data["signatureInfos"])) {
                this.signatureInfos = [] as any;
                for (let item of _data["signatureInfos"])
                    this.signatureInfos!.push(SignatureInfo.fromJS(item));
            }
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): BasicInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BasicInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountCode"] = this.accountCode;
        data["title"] = this.title;
        data["refId"] = this.refId;
        data["customerId"] = this.customerId;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["otherName"] = this.otherName;
        data["gender"] = this.gender;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["countryOfOriginId"] = this.countryOfOriginId;
        data["stateOfOriginId"] = this.stateOfOriginId;
        data["lgaOfOriginId"] = this.lgaOfOriginId;
        data["relationshipManager"] = this.relationshipManager;
        data["introducerType"] = this.introducerType;
        data["introducer"] = this.introducer;
        data["transactionReference"] = this.transactionReference;
        data["maidenName"] = this.maidenName;
        data["chn"] = this.chn;
        data["shareHoderTypeCode"] = this.shareHoderTypeCode;
        data["companyRegCode"] = this.companyRegCode;
        if (Array.isArray(this.bankInfos)) {
            data["bankInfos"] = [];
            for (let item of this.bankInfos)
                data["bankInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.contactInfos)) {
            data["contactInfos"] = [];
            for (let item of this.contactInfos)
                data["contactInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.employmentInfos)) {
            data["employmentInfos"] = [];
            for (let item of this.employmentInfos)
                data["employmentInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.identifications)) {
            data["identifications"] = [];
            for (let item of this.identifications)
                data["identifications"].push(item.toJSON());
        }
        if (Array.isArray(this.nextOfKins)) {
            data["nextOfKins"] = [];
            for (let item of this.nextOfKins)
                data["nextOfKins"].push(item.toJSON());
        }
        if (Array.isArray(this.signatureInfos)) {
            data["signatureInfos"] = [];
            for (let item of this.signatureInfos)
                data["signatureInfos"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): BasicInfo {
        const json = this.toJSON();
        let result = new BasicInfo();
        result.init(json);
        return result;
    }
}

export interface IBasicInfo {
    accountCode: number;
    title: string | undefined;
    refId: number;
    customerId: number;
    lastName: string | undefined;
    firstName: string | undefined;
    otherName: string | undefined;
    gender: string | undefined;
    dateOfBirth: Date | undefined;
    countryOfOriginId: number | undefined;
    stateOfOriginId: number | undefined;
    lgaOfOriginId: number | undefined;
    relationshipManager: string | undefined;
    introducerType: string | undefined;
    introducer: string | undefined;
    transactionReference: string | undefined;
    maidenName: string | undefined;
    chn: string | undefined;
    shareHoderTypeCode: string | undefined;
    companyRegCode: number;
    bankInfos: BankInfo[] | undefined;
    contactInfos: ContactInfo[] | undefined;
    employmentInfos: EmploymentInfo[] | undefined;
    identifications: Identification[] | undefined;
    nextOfKins: NextOfKin[] | undefined;
    signatureInfos: SignatureInfo[] | undefined;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class EventLog implements IEventLog {
    id!: number;
    basicInfoId!: number;
    logType!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    dateCreated!: Date;
    createdBy!: string | undefined;
    basicInfo!: BasicInfo;

    constructor(data?: IEventLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.basicInfoId = _data["basicInfoId"];
            this.logType = _data["logType"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventLog {
        data = typeof data === 'object' ? data : {};
        let result = new EventLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["basicInfoId"] = this.basicInfoId;
        data["logType"] = this.logType;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): EventLog {
        const json = this.toJSON();
        let result = new EventLog();
        result.init(json);
        return result;
    }
}

export interface IEventLog {
    id: number;
    basicInfoId: number;
    logType: string | undefined;
    title: string | undefined;
    description: string | undefined;
    dateCreated: Date;
    createdBy: string | undefined;
    basicInfo: BasicInfo;
}

export class EventLogIListApiResult implements IEventLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EventLog[] | undefined;
    totalCount!: number;

    constructor(data?: IEventLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EventLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EventLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EventLogIListApiResult {
        const json = this.toJSON();
        let result = new EventLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EventLog[] | undefined;
    totalCount: number;
}

export class FundTransactionDTO implements IFundTransactionDTO {
    basicInfoId!: number;
    accountCode!: string | undefined;
    accountName!: string | undefined;
    subscriptionAmount!: number;
    unitsAlloted!: number;
    transactionDate!: Date;
    price!: number;
    bvn!: string | undefined;
    status!: string | undefined;
    companyRegCode!: string | undefined;
    companyName!: string | undefined;
    narration!: string | undefined;
    transactionReference!: string | undefined;

    constructor(data?: IFundTransactionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.accountCode = _data["accountCode"];
            this.accountName = _data["accountName"];
            this.subscriptionAmount = _data["subscriptionAmount"];
            this.unitsAlloted = _data["unitsAlloted"];
            this.transactionDate = _data["transactionDate"] ? new Date(_data["transactionDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.bvn = _data["bvn"];
            this.status = _data["status"];
            this.companyRegCode = _data["companyRegCode"];
            this.companyName = _data["companyName"];
            this.narration = _data["narration"];
            this.transactionReference = _data["transactionReference"];
        }
    }

    static fromJS(data: any): FundTransactionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FundTransactionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["accountCode"] = this.accountCode;
        data["accountName"] = this.accountName;
        data["subscriptionAmount"] = this.subscriptionAmount;
        data["unitsAlloted"] = this.unitsAlloted;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["bvn"] = this.bvn;
        data["status"] = this.status;
        data["companyRegCode"] = this.companyRegCode;
        data["companyName"] = this.companyName;
        data["narration"] = this.narration;
        data["transactionReference"] = this.transactionReference;
        return data;
    }

    clone(): FundTransactionDTO {
        const json = this.toJSON();
        let result = new FundTransactionDTO();
        result.init(json);
        return result;
    }
}

export interface IFundTransactionDTO {
    basicInfoId: number;
    accountCode: string | undefined;
    accountName: string | undefined;
    subscriptionAmount: number;
    unitsAlloted: number;
    transactionDate: Date;
    price: number;
    bvn: string | undefined;
    status: string | undefined;
    companyRegCode: string | undefined;
    companyName: string | undefined;
    narration: string | undefined;
    transactionReference: string | undefined;
}

export class FundTransactionDTOIListApiResult implements IFundTransactionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: FundTransactionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IFundTransactionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FundTransactionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FundTransactionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new FundTransactionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FundTransactionDTOIListApiResult {
        const json = this.toJSON();
        let result = new FundTransactionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IFundTransactionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: FundTransactionDTO[] | undefined;
    totalCount: number;
}

export class Country implements ICountry {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    isActive!: boolean;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    id: number;
    name: string | undefined;
    code: string | undefined;
    isActive: boolean;
}

export class CountryIListApiResult implements ICountryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Country[] | undefined;
    totalCount!: number;

    constructor(data?: ICountryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Country.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CountryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CountryIListApiResult {
        const json = this.toJSON();
        let result = new CountryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICountryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Country[] | undefined;
    totalCount: number;
}

export class State implements IState {
    id!: number;
    countryId!: number;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    id: number;
    countryId: number;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class StateIListApiResult implements IStateIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: State[] | undefined;
    totalCount!: number;

    constructor(data?: IStateIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(State.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StateIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StateIListApiResult {
        const json = this.toJSON();
        let result = new StateIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IStateIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: State[] | undefined;
    totalCount: number;
}

export class Lga implements ILga {
    id!: number;
    stateId!: number;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;

    constructor(data?: ILga) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stateId = _data["stateId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Lga {
        data = typeof data === 'object' ? data : {};
        let result = new Lga();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stateId"] = this.stateId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): Lga {
        const json = this.toJSON();
        let result = new Lga();
        result.init(json);
        return result;
    }
}

export interface ILga {
    id: number;
    stateId: number;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class LgaIListApiResult implements ILgaIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Lga[] | undefined;
    totalCount!: number;

    constructor(data?: ILgaIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Lga.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LgaIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LgaIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LgaIListApiResult {
        const json = this.toJSON();
        let result = new LgaIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILgaIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Lga[] | undefined;
    totalCount: number;
}

export class RedemptionOutputDTO implements IRedemptionOutputDTO {
    isComplete!: boolean;
    unitsHeld!: number;
    dateCompleted!: Date | undefined;
    transactionReference!: string | undefined;
    basicInfoId!: number;
    accountCode!: number;
    accountName!: string | undefined;
    subscriptionAmount!: number;
    unitsToBeRedeemed!: number;
    transactionDate!: Date;
    bvn!: string | undefined;
    companyRegCode!: number;
    companyName!: string | undefined;
    narration!: string | undefined;

    constructor(data?: IRedemptionOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isComplete = _data["isComplete"];
            this.unitsHeld = _data["unitsHeld"];
            this.dateCompleted = _data["dateCompleted"] ? new Date(_data["dateCompleted"].toString()) : <any>undefined;
            this.transactionReference = _data["transactionReference"];
            this.basicInfoId = _data["basicInfoId"];
            this.accountCode = _data["accountCode"];
            this.accountName = _data["accountName"];
            this.subscriptionAmount = _data["subscriptionAmount"];
            this.unitsToBeRedeemed = _data["unitsToBeRedeemed"];
            this.transactionDate = _data["transactionDate"] ? new Date(_data["transactionDate"].toString()) : <any>undefined;
            this.bvn = _data["bvn"];
            this.companyRegCode = _data["companyRegCode"];
            this.companyName = _data["companyName"];
            this.narration = _data["narration"];
        }
    }

    static fromJS(data: any): RedemptionOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RedemptionOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isComplete"] = this.isComplete;
        data["unitsHeld"] = this.unitsHeld;
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["transactionReference"] = this.transactionReference;
        data["basicInfoId"] = this.basicInfoId;
        data["accountCode"] = this.accountCode;
        data["accountName"] = this.accountName;
        data["subscriptionAmount"] = this.subscriptionAmount;
        data["unitsToBeRedeemed"] = this.unitsToBeRedeemed;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["bvn"] = this.bvn;
        data["companyRegCode"] = this.companyRegCode;
        data["companyName"] = this.companyName;
        data["narration"] = this.narration;
        return data;
    }

    clone(): RedemptionOutputDTO {
        const json = this.toJSON();
        let result = new RedemptionOutputDTO();
        result.init(json);
        return result;
    }
}

export interface IRedemptionOutputDTO {
    isComplete: boolean;
    unitsHeld: number;
    dateCompleted: Date | undefined;
    transactionReference: string | undefined;
    basicInfoId: number;
    accountCode: number;
    accountName: string | undefined;
    subscriptionAmount: number;
    unitsToBeRedeemed: number;
    transactionDate: Date;
    bvn: string | undefined;
    companyRegCode: number;
    companyName: string | undefined;
    narration: string | undefined;
}

export class RedemptionOutputDTOIListApiResult implements IRedemptionOutputDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RedemptionOutputDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRedemptionOutputDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RedemptionOutputDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RedemptionOutputDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RedemptionOutputDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RedemptionOutputDTOIListApiResult {
        const json = this.toJSON();
        let result = new RedemptionOutputDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRedemptionOutputDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RedemptionOutputDTO[] | undefined;
    totalCount: number;
}

export class RedemptionInputDTO implements IRedemptionInputDTO {
    basicInfoId!: number;
    accountCode!: number;
    accountName!: string | undefined;
    subscriptionAmount!: number;
    unitsToBeRedeemed!: number;
    transactionDate!: Date;
    bvn!: string | undefined;
    companyRegCode!: number;
    companyName!: string | undefined;
    narration!: string | undefined;

    constructor(data?: IRedemptionInputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfoId = _data["basicInfoId"];
            this.accountCode = _data["accountCode"];
            this.accountName = _data["accountName"];
            this.subscriptionAmount = _data["subscriptionAmount"];
            this.unitsToBeRedeemed = _data["unitsToBeRedeemed"];
            this.transactionDate = _data["transactionDate"] ? new Date(_data["transactionDate"].toString()) : <any>undefined;
            this.bvn = _data["bvn"];
            this.companyRegCode = _data["companyRegCode"];
            this.companyName = _data["companyName"];
            this.narration = _data["narration"];
        }
    }

    static fromJS(data: any): RedemptionInputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RedemptionInputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfoId"] = this.basicInfoId;
        data["accountCode"] = this.accountCode;
        data["accountName"] = this.accountName;
        data["subscriptionAmount"] = this.subscriptionAmount;
        data["unitsToBeRedeemed"] = this.unitsToBeRedeemed;
        data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["bvn"] = this.bvn;
        data["companyRegCode"] = this.companyRegCode;
        data["companyName"] = this.companyName;
        data["narration"] = this.narration;
        return data;
    }

    clone(): RedemptionInputDTO {
        const json = this.toJSON();
        let result = new RedemptionInputDTO();
        result.init(json);
        return result;
    }
}

export interface IRedemptionInputDTO {
    basicInfoId: number;
    accountCode: number;
    accountName: string | undefined;
    subscriptionAmount: number;
    unitsToBeRedeemed: number;
    transactionDate: Date;
    bvn: string | undefined;
    companyRegCode: number;
    companyName: string | undefined;
    narration: string | undefined;
}

export class ValidateRRedemptionDTO implements IValidateRRedemptionDTO {
    transactionReference!: string | undefined;
    otp!: string | undefined;

    constructor(data?: IValidateRRedemptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionReference = _data["transactionReference"];
            this.otp = _data["otp"];
        }
    }

    static fromJS(data: any): ValidateRRedemptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateRRedemptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionReference"] = this.transactionReference;
        data["otp"] = this.otp;
        return data;
    }

    clone(): ValidateRRedemptionDTO {
        const json = this.toJSON();
        let result = new ValidateRRedemptionDTO();
        result.init(json);
        return result;
    }
}

export interface IValidateRRedemptionDTO {
    transactionReference: string | undefined;
    otp: string | undefined;
}

export class StringListApiResult implements IStringListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: string[] | undefined;
    totalCount!: number;

    constructor(data?: IStringListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StringListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StringListApiResult {
        const json = this.toJSON();
        let result = new StringListApiResult();
        result.init(json);
        return result;
    }
}

export interface IStringListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: string[] | undefined;
    totalCount: number;
}

export class SearchModel implements ISearchModel {
    id!: number;
    searchType!: string | undefined;
    searchText!: string | undefined;
    pageSize!: number;
    pageNumber!: number;

    constructor(data?: ISearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.searchType = _data["searchType"];
            this.searchText = _data["searchText"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): SearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["searchType"] = this.searchType;
        data["searchText"] = this.searchText;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }

    clone(): SearchModel {
        const json = this.toJSON();
        let result = new SearchModel();
        result.init(json);
        return result;
    }
}

export interface ISearchModel {
    id: number;
    searchType: string | undefined;
    searchText: string | undefined;
    pageSize: number;
    pageNumber: number;
}

export class BasicInfoOutputDTO implements IBasicInfoOutputDTO {
    lgaOfOrigin!: string | undefined;
    stateOfOrigin!: string | undefined;
    countryOfOrigin!: string | undefined;
    id!: number;
    accountCode!: number;
    title!: string | undefined;
    refId!: number;
    customerId!: number;
    lastName!: string | undefined;
    firstName!: string | undefined;
    otherName!: string | undefined;
    gender!: string | undefined;
    dateOfBirth!: Date | undefined;
    countryOfOriginId!: number | undefined;
    stateOfOriginId!: number | undefined;
    lgaOfOriginId!: number | undefined;
    relationshipManager!: string | undefined;
    introducerType!: string | undefined;
    introducer!: string | undefined;
    transactionReference!: string | undefined;
    maidenName!: string | undefined;
    chn!: string | undefined;
    shareHoderTypeCode!: string | undefined;
    companyRegCode!: number;

    constructor(data?: IBasicInfoOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lgaOfOrigin = _data["lgaOfOrigin"];
            this.stateOfOrigin = _data["stateOfOrigin"];
            this.countryOfOrigin = _data["countryOfOrigin"];
            this.id = _data["id"];
            this.accountCode = _data["accountCode"];
            this.title = _data["title"];
            this.refId = _data["refId"];
            this.customerId = _data["customerId"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.otherName = _data["otherName"];
            this.gender = _data["gender"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.countryOfOriginId = _data["countryOfOriginId"];
            this.stateOfOriginId = _data["stateOfOriginId"];
            this.lgaOfOriginId = _data["lgaOfOriginId"];
            this.relationshipManager = _data["relationshipManager"];
            this.introducerType = _data["introducerType"];
            this.introducer = _data["introducer"];
            this.transactionReference = _data["transactionReference"];
            this.maidenName = _data["maidenName"];
            this.chn = _data["chn"];
            this.shareHoderTypeCode = _data["shareHoderTypeCode"];
            this.companyRegCode = _data["companyRegCode"];
        }
    }

    static fromJS(data: any): BasicInfoOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BasicInfoOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lgaOfOrigin"] = this.lgaOfOrigin;
        data["stateOfOrigin"] = this.stateOfOrigin;
        data["countryOfOrigin"] = this.countryOfOrigin;
        data["id"] = this.id;
        data["accountCode"] = this.accountCode;
        data["title"] = this.title;
        data["refId"] = this.refId;
        data["customerId"] = this.customerId;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["otherName"] = this.otherName;
        data["gender"] = this.gender;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["countryOfOriginId"] = this.countryOfOriginId;
        data["stateOfOriginId"] = this.stateOfOriginId;
        data["lgaOfOriginId"] = this.lgaOfOriginId;
        data["relationshipManager"] = this.relationshipManager;
        data["introducerType"] = this.introducerType;
        data["introducer"] = this.introducer;
        data["transactionReference"] = this.transactionReference;
        data["maidenName"] = this.maidenName;
        data["chn"] = this.chn;
        data["shareHoderTypeCode"] = this.shareHoderTypeCode;
        data["companyRegCode"] = this.companyRegCode;
        return data;
    }

    clone(): BasicInfoOutputDTO {
        const json = this.toJSON();
        let result = new BasicInfoOutputDTO();
        result.init(json);
        return result;
    }
}

export interface IBasicInfoOutputDTO {
    lgaOfOrigin: string | undefined;
    stateOfOrigin: string | undefined;
    countryOfOrigin: string | undefined;
    id: number;
    accountCode: number;
    title: string | undefined;
    refId: number;
    customerId: number;
    lastName: string | undefined;
    firstName: string | undefined;
    otherName: string | undefined;
    gender: string | undefined;
    dateOfBirth: Date | undefined;
    countryOfOriginId: number | undefined;
    stateOfOriginId: number | undefined;
    lgaOfOriginId: number | undefined;
    relationshipManager: string | undefined;
    introducerType: string | undefined;
    introducer: string | undefined;
    transactionReference: string | undefined;
    maidenName: string | undefined;
    chn: string | undefined;
    shareHoderTypeCode: string | undefined;
    companyRegCode: number;
}

export class RegistrationSummaryOutputDTO implements IRegistrationSummaryOutputDTO {
    basicInfo!: BasicInfoOutputDTO;

    constructor(data?: IRegistrationSummaryOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfo = _data["basicInfo"] ? BasicInfoOutputDTO.fromJS(_data["basicInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegistrationSummaryOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationSummaryOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): RegistrationSummaryOutputDTO {
        const json = this.toJSON();
        let result = new RegistrationSummaryOutputDTO();
        result.init(json);
        return result;
    }
}

export interface IRegistrationSummaryOutputDTO {
    basicInfo: BasicInfoOutputDTO;
}

export class RegistrationSummaryOutputDTOListApiResult implements IRegistrationSummaryOutputDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RegistrationSummaryOutputDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRegistrationSummaryOutputDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RegistrationSummaryOutputDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RegistrationSummaryOutputDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationSummaryOutputDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RegistrationSummaryOutputDTOListApiResult {
        const json = this.toJSON();
        let result = new RegistrationSummaryOutputDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRegistrationSummaryOutputDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RegistrationSummaryOutputDTO[] | undefined;
    totalCount: number;
}

export class ContactInfoOutputDTO implements IContactInfoOutputDTO {
    state!: string | undefined;
    country!: string | undefined;
    basicInfoId!: number;
    address!: string | undefined;
    city!: string | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    zipCode!: string | undefined;
    mobilePhone!: string | undefined;
    homePhone!: string | undefined;
    emailAddress!: string | undefined;
    webAddress!: string | undefined;
    isDefault!: boolean;

    constructor(data?: IContactInfoOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.country = _data["country"];
            this.basicInfoId = _data["basicInfoId"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.zipCode = _data["zipCode"];
            this.mobilePhone = _data["mobilePhone"];
            this.homePhone = _data["homePhone"];
            this.emailAddress = _data["emailAddress"];
            this.webAddress = _data["webAddress"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactInfoOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["country"] = this.country;
        data["basicInfoId"] = this.basicInfoId;
        data["address"] = this.address;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["zipCode"] = this.zipCode;
        data["mobilePhone"] = this.mobilePhone;
        data["homePhone"] = this.homePhone;
        data["emailAddress"] = this.emailAddress;
        data["webAddress"] = this.webAddress;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): ContactInfoOutputDTO {
        const json = this.toJSON();
        let result = new ContactInfoOutputDTO();
        result.init(json);
        return result;
    }
}

export interface IContactInfoOutputDTO {
    state: string | undefined;
    country: string | undefined;
    basicInfoId: number;
    address: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    zipCode: string | undefined;
    mobilePhone: string | undefined;
    homePhone: string | undefined;
    emailAddress: string | undefined;
    webAddress: string | undefined;
    isDefault: boolean;
}

export class BankInfoOutputDTO implements IBankInfoOutputDTO {
    bankName!: string | undefined;
    basicInfoId!: number;
    bvn!: string | undefined;
    accountNo!: string | undefined;
    accountName!: string | undefined;
    bankId!: number | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: IBankInfoOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.basicInfoId = _data["basicInfoId"];
            this.bvn = _data["bvn"];
            this.accountNo = _data["accountNo"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): BankInfoOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BankInfoOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["basicInfoId"] = this.basicInfoId;
        data["bvn"] = this.bvn;
        data["accountNo"] = this.accountNo;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): BankInfoOutputDTO {
        const json = this.toJSON();
        let result = new BankInfoOutputDTO();
        result.init(json);
        return result;
    }
}

export interface IBankInfoOutputDTO {
    bankName: string | undefined;
    basicInfoId: number;
    bvn: string | undefined;
    accountNo: string | undefined;
    accountName: string | undefined;
    bankId: number | undefined;
    isDefault: boolean | undefined;
}

export class NextOfKinOutputDTO implements INextOfKinOutputDTO {
    title!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    basicInfoId!: number;
    titleId!: number | undefined;
    lastName!: string | undefined;
    firstName!: string | undefined;
    otherName!: string | undefined;
    address!: string | undefined;
    city!: string | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    phone!: string | undefined;
    email!: string | undefined;
    relationship!: string | undefined;

    constructor(data?: INextOfKinOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.basicInfoId = _data["basicInfoId"];
            this.titleId = _data["titleId"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.otherName = _data["otherName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.relationship = _data["relationship"];
        }
    }

    static fromJS(data: any): NextOfKinOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NextOfKinOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["state"] = this.state;
        data["country"] = this.country;
        data["basicInfoId"] = this.basicInfoId;
        data["titleId"] = this.titleId;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["otherName"] = this.otherName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["relationship"] = this.relationship;
        return data;
    }

    clone(): NextOfKinOutputDTO {
        const json = this.toJSON();
        let result = new NextOfKinOutputDTO();
        result.init(json);
        return result;
    }
}

export interface INextOfKinOutputDTO {
    title: string | undefined;
    state: string | undefined;
    country: string | undefined;
    basicInfoId: number;
    titleId: number | undefined;
    lastName: string | undefined;
    firstName: string | undefined;
    otherName: string | undefined;
    address: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    phone: string | undefined;
    email: string | undefined;
    relationship: string | undefined;
}

export class RegistrationOutputDTO implements IRegistrationOutputDTO {
    basicInfo!: BasicInfoOutputDTO;
    contactInfoList!: ContactInfoOutputDTO[] | undefined;
    bankInfoList!: BankInfoOutputDTO[] | undefined;
    employmentInfoList!: EmploymentInfo[] | undefined;
    identificationList!: Identification[] | undefined;
    nextOfKinList!: NextOfKinOutputDTO[] | undefined;
    signatureList!: SignatureInfo[] | undefined;

    constructor(data?: IRegistrationOutputDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfo = _data["basicInfo"] ? BasicInfoOutputDTO.fromJS(_data["basicInfo"]) : <any>undefined;
            if (Array.isArray(_data["contactInfoList"])) {
                this.contactInfoList = [] as any;
                for (let item of _data["contactInfoList"])
                    this.contactInfoList!.push(ContactInfoOutputDTO.fromJS(item));
            }
            if (Array.isArray(_data["bankInfoList"])) {
                this.bankInfoList = [] as any;
                for (let item of _data["bankInfoList"])
                    this.bankInfoList!.push(BankInfoOutputDTO.fromJS(item));
            }
            if (Array.isArray(_data["employmentInfoList"])) {
                this.employmentInfoList = [] as any;
                for (let item of _data["employmentInfoList"])
                    this.employmentInfoList!.push(EmploymentInfo.fromJS(item));
            }
            if (Array.isArray(_data["identificationList"])) {
                this.identificationList = [] as any;
                for (let item of _data["identificationList"])
                    this.identificationList!.push(Identification.fromJS(item));
            }
            if (Array.isArray(_data["nextOfKinList"])) {
                this.nextOfKinList = [] as any;
                for (let item of _data["nextOfKinList"])
                    this.nextOfKinList!.push(NextOfKinOutputDTO.fromJS(item));
            }
            if (Array.isArray(_data["signatureList"])) {
                this.signatureList = [] as any;
                for (let item of _data["signatureList"])
                    this.signatureList!.push(SignatureInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistrationOutputDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationOutputDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.contactInfoList)) {
            data["contactInfoList"] = [];
            for (let item of this.contactInfoList)
                data["contactInfoList"].push(item.toJSON());
        }
        if (Array.isArray(this.bankInfoList)) {
            data["bankInfoList"] = [];
            for (let item of this.bankInfoList)
                data["bankInfoList"].push(item.toJSON());
        }
        if (Array.isArray(this.employmentInfoList)) {
            data["employmentInfoList"] = [];
            for (let item of this.employmentInfoList)
                data["employmentInfoList"].push(item.toJSON());
        }
        if (Array.isArray(this.identificationList)) {
            data["identificationList"] = [];
            for (let item of this.identificationList)
                data["identificationList"].push(item.toJSON());
        }
        if (Array.isArray(this.nextOfKinList)) {
            data["nextOfKinList"] = [];
            for (let item of this.nextOfKinList)
                data["nextOfKinList"].push(item.toJSON());
        }
        if (Array.isArray(this.signatureList)) {
            data["signatureList"] = [];
            for (let item of this.signatureList)
                data["signatureList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistrationOutputDTO {
        const json = this.toJSON();
        let result = new RegistrationOutputDTO();
        result.init(json);
        return result;
    }
}

export interface IRegistrationOutputDTO {
    basicInfo: BasicInfoOutputDTO;
    contactInfoList: ContactInfoOutputDTO[] | undefined;
    bankInfoList: BankInfoOutputDTO[] | undefined;
    employmentInfoList: EmploymentInfo[] | undefined;
    identificationList: Identification[] | undefined;
    nextOfKinList: NextOfKinOutputDTO[] | undefined;
    signatureList: SignatureInfo[] | undefined;
}

export class RegistrationOutputDTOApiResult implements IRegistrationOutputDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RegistrationOutputDTO;
    totalCount!: number;

    constructor(data?: IRegistrationOutputDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RegistrationOutputDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RegistrationOutputDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationOutputDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RegistrationOutputDTOApiResult {
        const json = this.toJSON();
        let result = new RegistrationOutputDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRegistrationOutputDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RegistrationOutputDTO;
    totalCount: number;
}

export class RegistrationDTO implements IRegistrationDTO {
    basicInfo!: BasicInfo;

    constructor(data?: IRegistrationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicInfo = _data["basicInfo"] ? BasicInfo.fromJS(_data["basicInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegistrationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicInfo"] = this.basicInfo ? this.basicInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): RegistrationDTO {
        const json = this.toJSON();
        let result = new RegistrationDTO();
        result.init(json);
        return result;
    }
}

export interface IRegistrationDTO {
    basicInfo: BasicInfo;
}

export class TransactionHistoryDTO implements ITransactionHistoryDTO {
    shareID!: number;
    regcode!: number;
    certNo!: number;
    registrar!: string | undefined;
    unit!: number;
    transDate!: Date | undefined;
    description!: string | undefined;
    transType!: string | undefined;

    constructor(data?: ITransactionHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shareID = _data["shareID"];
            this.regcode = _data["regcode"];
            this.certNo = _data["certNo"];
            this.registrar = _data["registrar"];
            this.unit = _data["unit"];
            this.transDate = _data["transDate"] ? new Date(_data["transDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.transType = _data["transType"];
        }
    }

    static fromJS(data: any): TransactionHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareID"] = this.shareID;
        data["regcode"] = this.regcode;
        data["certNo"] = this.certNo;
        data["registrar"] = this.registrar;
        data["unit"] = this.unit;
        data["transDate"] = this.transDate ? this.transDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["transType"] = this.transType;
        return data;
    }

    clone(): TransactionHistoryDTO {
        const json = this.toJSON();
        let result = new TransactionHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface ITransactionHistoryDTO {
    shareID: number;
    regcode: number;
    certNo: number;
    registrar: string | undefined;
    unit: number;
    transDate: Date | undefined;
    description: string | undefined;
    transType: string | undefined;
}

export class TransactionHistoryDTOIListApiResult implements ITransactionHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TransactionHistoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ITransactionHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TransactionHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TransactionHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TransactionHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new TransactionHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITransactionHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TransactionHistoryDTO[] | undefined;
    totalCount: number;
}

export class DividendHistoryDTO implements IDividendHistoryDTO {
    shareID!: number;
    paymentNo!: number | undefined;
    netAmount!: number;
    status!: string | undefined;
    dividendNo!: number | undefined;
    type!: string | undefined;
    registrar!: string | undefined;
    warrantNo!: number | undefined;
    datePaid!: Date | undefined;
    datePayable!: Date | undefined;
    holdings!: number;
    gross!: number;
    tax!: number;

    constructor(data?: IDividendHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shareID = _data["shareID"];
            this.paymentNo = _data["paymentNo"];
            this.netAmount = _data["netAmount"];
            this.status = _data["status"];
            this.dividendNo = _data["dividendNo"];
            this.type = _data["type"];
            this.registrar = _data["registrar"];
            this.warrantNo = _data["warrantNo"];
            this.datePaid = _data["datePaid"] ? new Date(_data["datePaid"].toString()) : <any>undefined;
            this.datePayable = _data["datePayable"] ? new Date(_data["datePayable"].toString()) : <any>undefined;
            this.holdings = _data["holdings"];
            this.gross = _data["gross"];
            this.tax = _data["tax"];
        }
    }

    static fromJS(data: any): DividendHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DividendHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareID"] = this.shareID;
        data["paymentNo"] = this.paymentNo;
        data["netAmount"] = this.netAmount;
        data["status"] = this.status;
        data["dividendNo"] = this.dividendNo;
        data["type"] = this.type;
        data["registrar"] = this.registrar;
        data["warrantNo"] = this.warrantNo;
        data["datePaid"] = this.datePaid ? this.datePaid.toISOString() : <any>undefined;
        data["datePayable"] = this.datePayable ? this.datePayable.toISOString() : <any>undefined;
        data["holdings"] = this.holdings;
        data["gross"] = this.gross;
        data["tax"] = this.tax;
        return data;
    }

    clone(): DividendHistoryDTO {
        const json = this.toJSON();
        let result = new DividendHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IDividendHistoryDTO {
    shareID: number;
    paymentNo: number | undefined;
    netAmount: number;
    status: string | undefined;
    dividendNo: number | undefined;
    type: string | undefined;
    registrar: string | undefined;
    warrantNo: number | undefined;
    datePaid: Date | undefined;
    datePayable: Date | undefined;
    holdings: number;
    gross: number;
    tax: number;
}

export class DividendHistoryDTOIListApiResult implements IDividendHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DividendHistoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IDividendHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DividendHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DividendHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DividendHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DividendHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new DividendHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDividendHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DividendHistoryDTO[] | undefined;
    totalCount: number;
}

export class ViewHoldingDTO implements IViewHoldingDTO {
    unit!: number;
    shareholderName!: string | undefined;
    companyName!: string | undefined;
    issueDate!: Date | undefined;
    claimed!: boolean | undefined;
    claimedDate!: Date | undefined;
    readonly isClaimed!: string | undefined;

    constructor(data?: IViewHoldingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unit = _data["unit"];
            this.shareholderName = _data["shareholderName"];
            this.companyName = _data["companyName"];
            this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
            this.claimed = _data["claimed"];
            this.claimedDate = _data["claimedDate"] ? new Date(_data["claimedDate"].toString()) : <any>undefined;
            (<any>this).isClaimed = _data["isClaimed"];
        }
    }

    static fromJS(data: any): ViewHoldingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ViewHoldingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        data["shareholderName"] = this.shareholderName;
        data["companyName"] = this.companyName;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["claimed"] = this.claimed;
        data["claimedDate"] = this.claimedDate ? this.claimedDate.toISOString() : <any>undefined;
        data["isClaimed"] = this.isClaimed;
        return data;
    }

    clone(): ViewHoldingDTO {
        const json = this.toJSON();
        let result = new ViewHoldingDTO();
        result.init(json);
        return result;
    }
}

export interface IViewHoldingDTO {
    unit: number;
    shareholderName: string | undefined;
    companyName: string | undefined;
    issueDate: Date | undefined;
    claimed: boolean | undefined;
    claimedDate: Date | undefined;
    isClaimed: string | undefined;
}

export class ViewHoldingDTOIListApiResult implements IViewHoldingDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ViewHoldingDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IViewHoldingDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ViewHoldingDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ViewHoldingDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ViewHoldingDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ViewHoldingDTOIListApiResult {
        const json = this.toJSON();
        let result = new ViewHoldingDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IViewHoldingDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ViewHoldingDTO[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data;
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOIListApiResult implements IApplicationRoleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationRoleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ApplicationRoleDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTOApiResult implements IApplicationRoleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApplicationRoleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ApplicationRoleDTOApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO;
    totalCount: number;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }

    clone(): PermissionDTO {
        const json = this.toJSON();
        let result = new PermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IPermissionDTO {
    id: number;
    name: string | undefined;
    code: string | undefined;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    roleId!: number;
    roleName!: string | undefined;
    permissions!: PermissionDTO[] | undefined;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): RolePermissionDTO {
        const json = this.toJSON();
        let result = new RolePermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTO {
    roleId: number;
    roleName: string | undefined;
    permissions: PermissionDTO[] | undefined;
}

export class RolePermissionDTOIListApiResult implements IRolePermissionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RolePermissionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RolePermissionDTOIListApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO[] | undefined;
    totalCount: number;
}

export class RolePermissionDTOApiResult implements IRolePermissionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RolePermissionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RolePermissionDTOApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO;
    totalCount: number;
}

export class RolePermissionMappingDTO implements IRolePermissionMappingDTO {
    roleId!: number;
    permissionIds!: number[];

    constructor(data?: IRolePermissionMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RolePermissionMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data;
    }

    clone(): RolePermissionMappingDTO {
        const json = this.toJSON();
        let result = new RolePermissionMappingDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMappingDTO {
    roleId: number;
    permissionIds: number[];
}

export class ManageChangeOfAddressDTO implements IManageChangeOfAddressDTO {
    id!: number;
    company_id!: number;
    oldAddress!: string;
    new_Address!: string;
    country_id!: number | undefined;
    dob!: Date | undefined;

    constructor(data?: IManageChangeOfAddressDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.oldAddress = _data["oldAddress"];
            this.new_Address = _data["new_Address"];
            this.country_id = _data["country_id"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ManageChangeOfAddressDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageChangeOfAddressDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["oldAddress"] = this.oldAddress;
        data["new_Address"] = this.new_Address;
        data["country_id"] = this.country_id;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        return data;
    }

    clone(): ManageChangeOfAddressDTO {
        const json = this.toJSON();
        let result = new ManageChangeOfAddressDTO();
        result.init(json);
        return result;
    }
}

export interface IManageChangeOfAddressDTO {
    id: number;
    company_id: number;
    oldAddress: string;
    new_Address: string;
    country_id: number | undefined;
    dob: Date | undefined;
}

export class ManageAccountConsolidateDTO implements IManageAccountConsolidateDTO {
    id!: number;
    companies!: string;
    accounts!: string;

    constructor(data?: IManageAccountConsolidateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companies = _data["companies"];
            this.accounts = _data["accounts"];
        }
    }

    static fromJS(data: any): ManageAccountConsolidateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageAccountConsolidateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companies"] = this.companies;
        data["accounts"] = this.accounts;
        return data;
    }

    clone(): ManageAccountConsolidateDTO {
        const json = this.toJSON();
        let result = new ManageAccountConsolidateDTO();
        result.init(json);
        return result;
    }
}

export interface IManageAccountConsolidateDTO {
    id: number;
    companies: string;
    accounts: string;
}

export class ChangeOfAddressDTO implements IChangeOfAddressDTO {
    id!: number;
    company_id!: number;
    oldAddress!: string | undefined;
    new_Address!: string | undefined;
    country_id!: number | undefined;
    dob!: Date | undefined;
    company_name!: string | undefined;
    country_name!: string | undefined;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    userId!: number;
    requestTypeId!: number;
    approvalStatus!: number;
    dateApproved!: Date | undefined;
    readonly requestTypeName!: string | undefined;
    readonly approvalStatusName!: string | undefined;

    constructor(data?: IChangeOfAddressDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.oldAddress = _data["oldAddress"];
            this.new_Address = _data["new_Address"];
            this.country_id = _data["country_id"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.company_name = _data["company_name"];
            this.country_name = _data["country_name"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.userId = _data["userId"];
            this.requestTypeId = _data["requestTypeId"];
            this.approvalStatus = _data["approvalStatus"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            (<any>this).requestTypeName = _data["requestTypeName"];
            (<any>this).approvalStatusName = _data["approvalStatusName"];
        }
    }

    static fromJS(data: any): ChangeOfAddressDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeOfAddressDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["oldAddress"] = this.oldAddress;
        data["new_Address"] = this.new_Address;
        data["country_id"] = this.country_id;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["company_name"] = this.company_name;
        data["country_name"] = this.country_name;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["userId"] = this.userId;
        data["requestTypeId"] = this.requestTypeId;
        data["approvalStatus"] = this.approvalStatus;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["requestTypeName"] = this.requestTypeName;
        data["approvalStatusName"] = this.approvalStatusName;
        return data;
    }

    clone(): ChangeOfAddressDTO {
        const json = this.toJSON();
        let result = new ChangeOfAddressDTO();
        result.init(json);
        return result;
    }
}

export interface IChangeOfAddressDTO {
    id: number;
    company_id: number;
    oldAddress: string | undefined;
    new_Address: string | undefined;
    country_id: number | undefined;
    dob: Date | undefined;
    company_name: string | undefined;
    country_name: string | undefined;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    userId: number;
    requestTypeId: number;
    approvalStatus: number;
    dateApproved: Date | undefined;
    requestTypeName: string | undefined;
    approvalStatusName: string | undefined;
}

export class ChangeOfAddressDTOIListApiResult implements IChangeOfAddressDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ChangeOfAddressDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IChangeOfAddressDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ChangeOfAddressDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ChangeOfAddressDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeOfAddressDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ChangeOfAddressDTOIListApiResult {
        const json = this.toJSON();
        let result = new ChangeOfAddressDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IChangeOfAddressDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ChangeOfAddressDTO[] | undefined;
    totalCount: number;
}

export class FeatureDTO implements IFeatureDTO {
    id!: number;
    name!: string;

    constructor(data?: IFeatureDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FeatureDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): FeatureDTO {
        const json = this.toJSON();
        let result = new FeatureDTO();
        result.init(json);
        return result;
    }
}

export interface IFeatureDTO {
    id: number;
    name: string;
}

export class FeatureDTOIListApiResult implements IFeatureDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: FeatureDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IFeatureDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FeatureDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FeatureDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FeatureDTOIListApiResult {
        const json = this.toJSON();
        let result = new FeatureDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IFeatureDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: FeatureDTO[] | undefined;
    totalCount: number;
}

export class ManageSubscriptionDTO implements IManageSubscriptionDTO {
    id!: number;
    name!: string;
    amount!: number;
    subscriptionFeatures!: string | undefined;

    constructor(data?: IManageSubscriptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.amount = _data["amount"];
            this.subscriptionFeatures = _data["subscriptionFeatures"];
        }
    }

    static fromJS(data: any): ManageSubscriptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSubscriptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["amount"] = this.amount;
        data["subscriptionFeatures"] = this.subscriptionFeatures;
        return data;
    }

    clone(): ManageSubscriptionDTO {
        const json = this.toJSON();
        let result = new ManageSubscriptionDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSubscriptionDTO {
    id: number;
    name: string;
    amount: number;
    subscriptionFeatures: string | undefined;
}

export class SubscriptionDTO implements ISubscriptionDTO {
    id!: number;
    name!: string | undefined;
    amount!: number;
    subscriptionFeatures!: FeatureDTO[] | undefined;

    constructor(data?: ISubscriptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.amount = _data["amount"];
            if (Array.isArray(_data["subscriptionFeatures"])) {
                this.subscriptionFeatures = [] as any;
                for (let item of _data["subscriptionFeatures"])
                    this.subscriptionFeatures!.push(FeatureDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["amount"] = this.amount;
        if (Array.isArray(this.subscriptionFeatures)) {
            data["subscriptionFeatures"] = [];
            for (let item of this.subscriptionFeatures)
                data["subscriptionFeatures"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubscriptionDTO {
        const json = this.toJSON();
        let result = new SubscriptionDTO();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionDTO {
    id: number;
    name: string | undefined;
    amount: number;
    subscriptionFeatures: FeatureDTO[] | undefined;
}

export class SubscriptionDTOIListApiResult implements ISubscriptionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SubscriptionDTOIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionDTO[] | undefined;
    totalCount: number;
}

export class SubscriptionDTOApiResult implements ISubscriptionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionDTO;
    totalCount!: number;

    constructor(data?: ISubscriptionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SubscriptionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SubscriptionDTOApiResult {
        const json = this.toJSON();
        let result = new SubscriptionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionDTO;
    totalCount: number;
}

export class UserSubscriptionDTO implements IUserSubscriptionDTO {
    subscriptionId!: number;
    isFreeMode!: boolean;
    subscriptionName!: string | undefined;

    constructor(data?: IUserSubscriptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isFreeMode = _data["isFreeMode"];
            this.subscriptionName = _data["subscriptionName"];
        }
    }

    static fromJS(data: any): UserSubscriptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserSubscriptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isFreeMode"] = this.isFreeMode;
        data["subscriptionName"] = this.subscriptionName;
        return data;
    }

    clone(): UserSubscriptionDTO {
        const json = this.toJSON();
        let result = new UserSubscriptionDTO();
        result.init(json);
        return result;
    }
}

export interface IUserSubscriptionDTO {
    subscriptionId: number;
    isFreeMode: boolean;
    subscriptionName: string | undefined;
}

export class UserSubscriptionDTOApiResult implements IUserSubscriptionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: UserSubscriptionDTO;
    totalCount!: number;

    constructor(data?: IUserSubscriptionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? UserSubscriptionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserSubscriptionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSubscriptionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserSubscriptionDTOApiResult {
        const json = this.toJSON();
        let result = new UserSubscriptionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IUserSubscriptionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: UserSubscriptionDTO;
    totalCount: number;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name!: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data;
    }

    clone(): SelectListGroup {
        const json = this.toJSON();
        let result = new SelectListGroup();
        result.init(json);
        return result;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name: string | undefined;
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group!: SelectListGroup;
    selected!: boolean;
    text!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data;
    }

    clone(): SelectListItem {
        const json = this.toJSON();
        let result = new SelectListItem();
        result.init(json);
        return result;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group: SelectListGroup;
    selected: boolean;
    text: string | undefined;
    value: string | undefined;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data;
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    locationID!: number | undefined;
    lgaid!: number | undefined;
    approvalAmtLimit!: number;
    approvalAmtMTD!: number;
    locationCol!: SelectListItem[] | undefined;
    lgaCol!: SelectListItem[] | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    dateCreated!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    isSynched!: boolean;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.locationID = _data["locationID"];
            this.lgaid = _data["lgaid"];
            this.approvalAmtLimit = _data["approvalAmtLimit"];
            this.approvalAmtMTD = _data["approvalAmtMTD"];
            if (Array.isArray(_data["locationCol"])) {
                this.locationCol = [] as any;
                for (let item of _data["locationCol"])
                    this.locationCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["lgaCol"])) {
                this.lgaCol = [] as any;
                for (let item of _data["lgaCol"])
                    this.lgaCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.isSynched = _data["isSynched"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["locationID"] = this.locationID;
        data["lgaid"] = this.lgaid;
        data["approvalAmtLimit"] = this.approvalAmtLimit;
        data["approvalAmtMTD"] = this.approvalAmtMTD;
        if (Array.isArray(this.locationCol)) {
            data["locationCol"] = [];
            for (let item of this.locationCol)
                data["locationCol"].push(item.toJSON());
        }
        if (Array.isArray(this.lgaCol)) {
            data["lgaCol"] = [];
            for (let item of this.lgaCol)
                data["lgaCol"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isSynched"] = this.isSynched;
        return data;
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    locationID: number | undefined;
    lgaid: number | undefined;
    approvalAmtLimit: number;
    approvalAmtMTD: number;
    locationCol: SelectListItem[] | undefined;
    lgaCol: SelectListItem[] | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    dateCreated: Date;
    isActive: boolean;
    isDeleted: boolean;
    isSynched: boolean;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data;
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
